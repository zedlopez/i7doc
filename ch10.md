# Chapter 10: Advanced Topics

To round out *The Inform 7 Handbook,* we’ll take a quick look
at some of the advanced topics that Inform authors sometimes need or
want to know about. We’re not going to provide every detail about any of
these topics – that would take a whole other book. But if you’re
wondering what may lie ahead in your adventures with Inform, this
chapter will help you get started on the right foot. For more details
about how to use the features described here, you’ll need to read the
Documentation and perhaps post messages to the IntFiction forum
requesting help.

## Story Tense and Viewpoint

Present tense and second person viewpoint are very widely used in
interactive fiction. For instance:

You can see a teapot and a vicious troll here.

“You” is second person (English makes no distinction between second
person singular and second person plural), and “can see” is present
tense. But what if you’d like to write a story in first person singular,
past tense? Or, more exotically, third person plural, future tense? The
current version of the Inform library provides fairly full support for
writing a game in any combination of tense and viewpoint, as explained
in [WI 14.1: Tense and narrative viewpoint](../WI_14.html#section_1). In fact,
you can switch tense and viewpoint at any point in the story, which
might be useful if one section of the story is a flashback to an earlier
time, or has a different viewpoint character.

If your game is written entirely with one tense and viewpoint, the
details of how the Standard Library does this magic trick may not be of
much interest. You can just put something like this near the beginning
of your source code, and you’re good to go:

```
When play begins:
	now the story viewpoint is first person singular;
	now the story tense is past tense.
```


This will produce output in the form:

{::options parse_block_html="false" /}
<div class="game-output">
<p>I could see a teapot and a vicious troll here.</p>

</div>
{::options parse_block_html="false" /}


If you need to switch from one viewpoint or tense to another during
the course of the game, you’ll probably want to make use of the same
kinds of text insertions that the Standard Library uses. These methods
are detailed in [WI Chapter 14: Adaptive Text and Responses](../WI_14.html).

## Code Optimization

In the 1970s, when the very first interactive fiction games were
written, computers were (by today’s standards) incredibly slow, and had
almost no memory. As a result, games – and every other type of software
– had to be written very efficiently. If the software had to do a lot of
churning, the user might issue a command and then have to wait ten or
twenty seconds for the computer’s response. Or all afternoon. Issue a
command, then go out for coffee, or come back tomorrow morning to find
out if your program did what you expected it to. This was annoying, to
say the least.

Today’s computers are incredibly fast, and have gigantic memory
capacities. So there’s no longer any need to think about optimizing your
game code.

At least, that was true ten years ago, when Inform 7 was first
designed. But since then, a couple of developments in the world of
personal computing have changed the picture somewhat.

First, text games are now being played on hand-held devices such as
cell phones. These gadgets have less memory than a desktop Mac or PC,
and their processors are slower too. Until next-generation hand-helds
get faster and boast more memory, optimizing your game so that it will
run smoothly on this growing family of devices will be important.

But there’s a bigger issue. Two new interpreters, Parchment (for .z5
and .z8 games) and Quixe (for Glulx games) have been released that run
directly in Web browsers. This is a terrific development, as it opens up
the potential audience for IF to millions of people who would be
unlikely to download a separate interpreter program. Other browser-based
terps are also appearing. What they have in common is that they’re
written in a language called Javascript. You don’t need to know a
blessed thing about Javascript in order to see your games running on one
of these interpreters – but you need to understand that Javascript can
be slow. Five years from now that bottleneck may have gone away, and IF
authors will be free to write free-wheeling, inefficient games. Until
then, you may want to think about utilizing a few programming techniques
that will optimize your Inform games.

For the following discussion, I’m relying on information from Ron
Newcomb, Andrew Plotkin, and others. They know a lot more about Inform,
and about programming in general, than I do. (Plotkin created Quixe, in
fact.)

### Instead of Instead

As noted previously regarding [efficiency](#ref_efficiency_box),
Inform’s mechanism for processing the player’s input by means of
rulebooks called Before, Instead, and After is inefficient. This is
because there’s only one of each of these rulebooks. On the other hand,
each action (such as EXAMINE, TAKE, and DROP) has its own Check, Carry
Out, and Report rulebooks. What this means is that each time the player
enters a command, the game will consult *all* of the Before,
Instead, and After rules that you’ve written to see if any of them
applies. In a large game, that could be hundreds of rules.

In many cases, you can easily replace Instead rules with Check and
Carry Out rules and After rules with Carry Out and/or Report rules.
Let’s start with a simple Check rule:

```
The player carries a rotten banana. The banana is edible.

Check eating the banana:
	say "Ewwww!" instead.

[Instead of eating the banana:
	say "Ewwww!"] [This produces the same result, but it's less efficient.]
```


The main difference between the two rules is that the Check rule has
to have the word “instead” tacked onto the end. If you forget to do this
(and it’s easy to forget), Inform will consult the Check rule and then
go on to run the Carry Out and Report rules for the action. The word
“instead” causes the rule to succeed, which is a technical way of saying
that nothing else will happen.

In exactly the same way, we can replace an After rule with a Report
rule, like this:

```
[After eating the banana:
	say "After chowing down on the banana, you feel a little ill."] [Not efficient.]

Report eating the banana:
	say "After chowing down on the banana, you feel a little ill.";
	rule succeeds.
```


Again, we have to tack on a little extra syntax (“rule succeeds”) to
shut off Inform’s default Report rule for the eating action – but if
you’re concerned about efficiency, this is a small price to pay.

Rewriting a Before rule as a Check or Carry Out rule is trickier, if
only because Before rules are intended for situations that are a little
tricky. I tend to use Before rules mostly in constructions like
this:

```
Before doing anything other than examining to the sky, say "The sky is too far away." instead.
```


This type of construction (“anything other than…”) can’t be used in
Check or Carry Out rules, simply because each action has its own set of
rulebooks.

### Every Turn Rules

In every turn, every Every Turn rule in your game will be consulted
to see whether it’s relevant. As your Every Turn rules proliferate, the
game will become less efficient. Fortunately, most of your Every Turn
rules will probably be targeted at specific circumstances, such as when
a certain scene is active or when the player is in a certain room. If
you group all of the Every Turn rules that apply to a given situation as
if-tests within a single rule, you’ll gain efficiency. For instance:

```
Every turn when in the Glue Factory:
	if the security guard is in the Factory:
		say "The guard belches loudly.";
	if Esmerelda is in the Factory:
		say "Esmerelda sighs winsomely.";
	if the blast furnace is heated:
		say "Heat radiates from the blast furnace.";
	[…and so on…]
```


When the player is in the Glue Factory, the fact that the rules are
grouped will change nothing – but whenever the player is *not* in
the Glue Factory, only one Every Turn rule will be consulted to see
whether it applies, rather than several of them.

### Other Ways to Streamline Your Code

Occasionally, the “after reading a command” activity will prove very
useful. But it runs each time the player types the Return key, so
putting a lot of if-tests in it will slow the game down. I’ve run into
one or two aspiring authors who thought it would be cool to basically
reinvent the parser by putting a bunch of stuff in the “after reading a
command” activity. To do this, they tried to write lots and lots of code
to figure out whether the player’s command included specific words.
That’s the parser’s job. If you can use an offstage object, a backdrop,
or an invisible part of the player, any of which can be given vocabulary
words, to direct the parser to the result you’re trying to create, that
will be more efficient – and also friendlier to the player and less
likely to include bugs.

## Tables

Tables are Inform’s way of organizing complicated blocks of data.
[WI Chapter 16: Tables](../WI_16.html),
will tell you a great deal about tables, but it won’t, at first glance,
give you a very clear idea why you might want to use a table. I’m pretty
sure you can write a complete and satisfying game without ever using
tables. They’re a specialized tool, used mainly when you have long lists
of stuff that you want to be able to organize and then get at during the
game. Tables are used in creating hint menus and conversation menus, for
instance.

When I asked the Inform experts for ideas about why an author might
want to use a table, Emily Short provided an excellent list. I’ll
include her suggestions below, with only minor editing, in case they
might give you an idea or two for your next game.

In a nutshell, here’s what you need to know about tables in order to
start using them:

The data in tables is organized into rows and columns. Each column
has a name, which is how you’ll refer to it while writing your game. The
table itself has a name too. The rows don’t have names; they’re
numbered. That is, they’re implicitly numbered – when you write out your
table, you don’t use numbers.

Each column can contain only one type of data. The first column might
contain things, for example, the second column numbers, and the third
and fourth columns text. If you try to mix up the columns, for instance
putting a number where text belongs, Inform won’t let you. An entry in
any row or column can be left blank by typing two hyphens (--).

When you create a table, you separate the data within each row by
using one or more Tab characters. Rows of space characters look the same
to you and me, but they won’t do the job. At the end of each column, you
hit a single Return/Enter, and then start the next column. Tables with
long texts tend to look quite jumbled on the Source page, but if you
follow these rules and ignore how the table looks on the screen, it will
work the way you want it to.

Let’s create a table, so that we can refer to it in the rest of this
section:

```
A furry menace is a kind of thing.

The gopher is a furry menace in the Meadow.
The muskrat is a furry menace in the Meadow.
The chipmunk is a furry menace in the Meadow.
The mole is a furry menace in the Meadow.

Table of Obnoxious Mammals
critter      name      weight
gopher      "Herman"   17
muskrat   "Vivian"   12
chipmunk   "Abercrombie"   9
mole      "Edith"      27
```


<div class="addendum">

    Table columns are separated by *any number of tab characters* so long as it's at least one. So one can make them look not ugly by going to the effort of inserting extra tabs between columns on a per row basis. But if you change a column's value to something of a different length, you're likely to need to adjust every other row to maintain it.
    For your reading pleasure, henceforth this document will graphically represent tables *as tables* though that's not what they'll look like in actual Inform source.
    
</div>


The first row under the table name contains the column headings
(critter, name, weight). These are just abstract words, as far as Inform
is concerned. I’d recommend not using a word that Inform is using for
something else, or that you’re using elsewhere in your own code. You
should avoid column headings like “location” and “container”, for
instance.

To use the data in any cell in the table, we can refer to it by the
line number and column heading. For instance, “the name in row 4 of the
Table of Obnoxious Mammals” is the text “Edith”. If you’re familiar with
computer programming, you’ll understand when I say that Inform’s table
rows are 1-indexed, not 0-indexed. In plain English, the number of the
first row is 1, not 0.

You can also get at the data in the table by cross-referencing the
data you want with the data in some other column, like this:

```
say "The name of the muskrat in the Table of Obnoxious Mammals is
[name corresponding to the critter of muskrat in the Table of Obnoxious
Mammals]."
```


Note the slightly weird syntax here. We have to say “corresponding to
the critter of muskrat” – we can’t say, “corresponding to the muskrat
critter.”

You may sometimes need to change the data in a table during the
course of the game. Inform’s standard “now … is” syntax will do the
job:

```
now the weight in row 1 of the Table of Obnoxious Mammals is 8;
```


It’s often useful to look at all of the data in a table, one row at a
time. Here’s one way to do that:

```
repeat with N running from 1 to the number of rows in the Table of Obnoxious Mammals:
	if the weight in row N of the Table of Obnoxious Mammals is greater than 15:
		say "[Name in row N of the Table of Obnoxious Mammals] is rather obese."
```


The phrase “repeat with N running from 1 to the number of Rows in the
Table of Mammals” is explained in [WI 16.6](../WI_16.html#section_6). This phrase has several elements. The
phrase “repeat with” creates a *loop.* Inform will run through
the code block below the “repeat with” statement over and over. The
first time through the loop, N will be 1. The second time through the
loop, N will be 2. And so forth. N is a *loop counter;* the words
“running from 1 to” are what tells Inform that N is a number, and that
it’s a loop counter. The phrase “the number of rows in the Table of
Mammals” should be obvious; in this case it’s 4, because our silly
little table has four rows. So the loop will run four times, and then
stop.

While the loop is running, we can use the number N (which is
different each time Inform goes through the loop) to do various things
to the data in the table. Mainly, we can look up data in row N, or we
can change it.

Here’s a more concise way of doing the same thing, without using a
loop counter:

```
repeat through the Table of Obnoxious Mammals:
	if the weight entry is greater than 15:
		say "[name entry] is rather obese."
```


As mentioned in [WI 16.12 Listed in…](../WI_16.html#section_12), when Inform looks at some data in a table
row, that row is automatically chosen. This makes it easy to refer to
the other data in the same row without having to tell the compiler what
row we’re talking about. Here’s an example that shows how this works.
Because we defined the objects that show up in the table as of the furry
menace kind, we can write a rule that will apply to any furry
menace:

```
Instead of examining a furry menace (called FM):
	if FM is a critter listed in the Table of Obnoxious Mammals: 
		say "[The FM] is named [name entry]."
```


We don’t need to say “[name corresponding to the FM in the Table of
Obnoxious Mammals]” – in fact, we can’t say it, because Inform won’t
know what it means. Because the row has already been chosen
automatically, “[name entry]” will work fine.

Sometimes you may need to change the data in a table entry. You can
do this by referring to an entry in another column of that same row,
which is convenient, because it means you don’t need to know the number
of the row the data is in. Continuing with our rather silly example,
we’re going to create a new action, altering, which will do nothing
except change the entry in the name column:

```
Altering is an action applying to one thing. Understand "alter [furry
menace]" as altering.

Carry out altering:
now the name corresponding to a critter of the noun in the Table of
Obnoxious Mammals is "Judy Garland";

say "Name altered."
```


The point of this example is to show the syntax. Two of the columns
are called name and critter, so “now the name corresponding to a critter
of the noun…” will let us alter the name of any of the critters to
“Judy Garland” by typing ALTER MOLE in the game, or ALTER MUSKRAT.

<div class="sidebar">

### Emily Short on Using Tables

The most common uses for me are these:


To manage background-event text. This might take the form of events
that need to happen in sequence, during a scene (see “Day One”), or it
might be a set of randomized atmosphere texts to be printed under
certain conditions. I use this trick *all the time*.

To store the mental equivalent of inventory. In my story
“Alabaster,” for instance, there is a long, long list of facts the
player might know, each of which has a short summary text to be printed
by THINK if the player has in fact discovered this fact. This
  information is stored like this:



  Table of All Known Facts
  
factsummary
snowshoes-worn"She is wearing snow shoes."
apple-pie"She really likes apple pie."




  …and so on, for dozens of lines. (Actual facts changed to protect
against spoilers.)

To give an NPC pert replies to being asked to do dumb things. I
find it most convenient to make a table of the different rules that
cause an action to fail, and then attach some reply text to each one.
([Example 188: Generation X](../examples/generation_x.html), demonstrates this.) I could also handle
this with a series of individual “unsuccessful attempt” rules, but
because there would have to be a large number of these, I find the table
is easier to take in at a glance.

To construct any kind of consultable object in which the player
needs to look things up: books, computers on which you conduct
Google-style searches, or the sort of NPC that exists chiefly to answer
questions. (Most of mine don’t, which is why I usually don’t use tables
to construct them; but I could imagine a robot librarian that would be
best implemented by a table.) Several reviewers commented favorably on
the computer database search in [Floatpoint](https://ifdb.org/viewgame?id=01efmfsk4r79mtks), and this would have been
vastly harder to set up without tables with topic columns.

To store flexible schedules. Inform has various time functions that
make it possible to write an inflexible schedule (X happens at a given
time of day, no matter what), but sometimes I like to have a
free-floating schedule that could start at any time. My extension
“Transit System” is a good example of this in action: Each row contains
a number of minutes and the name of a room, which is the stop where the
bus (say) ought to arrive after the requisite delay.


There are also some obscure programmatic uses to them, of which the
most obvious is perhaps:


  As an aid in extensions, whenever I want to create a sequence of
things to which the author of the game may need to add. Because tables
can very easily be amended or added to, they make good structures for an
extension designer to use. “Complex Listing” exemplifies this: It offer
several kinds of list-building options but allows the game author to add
    almost any kind of addition to the selection.
  


In practice, the things you can do with a table are not *that*
numerous. They basically boil down to:

To find your place in a table, you can step through the whole table
row by row. You can choose a specific row, by row number or by looking
for a specific value in one of the columns, or by selecting a blank row
with nothing in it yet.

Manipulating the contents of a particular row, once chosen: You can
read and use a table entry for something (for instance, to print text or
set a local variable). You can write something new in a table entry. Or
you can blank out a row of entries, eliminating them permanently.

You can manipulate the whole table by sorting the table to put one of
the columns in a specific order.

Even topic tables are just a special case of this, in that they have
a column with a special name (“topic”) and they allow the author some
shorthand for looking up rows in the table based on the player’s input –
but this is still just row-choosing stuff.

</div>


## The Skein


As explained in **pages 1.7 and 1.8** of *Writing
with Inform* (“The Skein” and “A short Skein tutorial”), the Skein
and Transcript panels are used to replay series of commands and examine
the output. All the time you’re testing your game in the Game panel,
Inform is quietly recording all of your commands and all of the output
from the game. The commands are added to the Skein.

At any time you can switch to the Skein and double-click on a node
(the Documentation calls them “knots”), and the game will first be
compiled and then replayed from the start up to that knot. The Skein is
like the Replay button in the top toolbar, except that it can replay
*any* playing session, not just the most recent one.

As you work on your game, the Skein can get pretty crowded with
branches (Inform calls them “threads”) that are no longer needed. You
can trim these out by right-clicking (Mac: Ctrl-clicking) and choosing
“Delete all below”. But you won’t be allowed to delete the currently
active thread – the one that represents the game that’s currently in
progress in the Game panel. If you want to do that, you first need to
click the Stop button in the toolbar. If you want to delete everything
in the Skein, you can use the Trim button. This will get rid of
everything except the currently active thread and any threads that you
have locked.

As your game gets closer to being finished, the Skein will become
quite useful. You can play the entire game manually from start to finish
– until you get to the ***** You have won ***** message (or
whatever message you’re using to indicate victory) – and then open the
Skein and *lock* the thread you’ve just created. Locking a thread
will stop Inform from deleting it, even if you use the Trim button. In
the Transcript panel, you can *bless* the output transcript for
this thread. Blessing tells Inform that this is the output you hope to
see in the final, released version of the game. Blessing has no actual
effect on the game itself; it’s just a record-keeping function. It
stores a transcript so that you can look at it later.

After making further changes in your game (to eliminate bugs, for
instance, or to add features suggested by your testers), you can run the
game again using the locked thread, as a quick check to make sure you
haven’t done anything that makes the game unwinnable. You can then
inspect the output in the Transcript to see what changes have appeared.
Using the “Next diff” and “Prev diff” buttons, you can step through any
changes that your recent work has made in the transcript.

There’s more to using the Skein and Transcript than we’ve covered in
this brief overview. After you’ve been writing in Inform for a while,
you’ll start to see how useful these features can be.

## Using the Index



I really shouldn’t have buried a discussion of the Index panel in the
Inform IDE way back here in Chapter 10, but I didn’t know where else to
put it. Until you’ve learned a bit about Inform programming, what you
see in the Index may not make a lot of sense. Once you’ve started
working with Inform, however, you’ll find it extremely useful.

The Index only appears after you have successfully compiled your game
at least once in your current work session. Until the project has been
compiled, the Index panel will be empty.

Across the top of the Index panel are eight buttons. The Home button
(highlighted in blue in the image at left) displays a navigation page to
the Index as a whole. By clicking the other tabs along the top, you can
view Contents, Actions, Kinds, the Phrasebook, Rules, Scenes, or the
World of your story. Alternatively, clicking on any of the square
buttons will take you directly to one of the subsections of the
index.

The main point of the Index, as you might expect, is to make it easy
to find things in your project. Many of the items listed in the Index
have clickable buttons beside them. Clicking an orange button with a
curving arrow will take you to the place in the Source where that item
is first mentioned. Clicking on a gray magnifying glass button will open
up a page of details deep within the Index, where you’ll see more
detail. Clicking a blue question-mark button will take you to a page in
*Writing with Inform* where the item is discussed.

On the main pages within the index, each square (such as “A1 Grouped”
in the Actions index or “Lx Lexicon” in the Phrasebook index) has at
least one blue question-mark button next to it. If you’re not sure what
type of item is being displayed in a given portion of the Index, click
on this button to go to the page where it’s discussed. Then use the Back
arrow in the upper left corner to return to the Index page.

Blue-gray squares in the Index can be clicked to copy a bit of code
into your source code at the spot where your text entry cursor is
located. Under Innards in the Contents page, for instance, you’ll find
squares that can insert Use options. (These should normally be placed
just after your story title, at the very start of the source code.)

If you scroll down a bit in the Phrases display in the Phrasebook
page, you’ll find a long list headlined “Saying.” Beneath this are
individual things that can be put into say phrases, with gray + buttons.
Clicking these buttons will give you a more detailed description of such
things as “say ‘[time in words]’”. Similar gray buttons are found in the
Standards display of the Rules index. If you spend a little time reading
the information on these pages, you’ll learn a lot about what you can do
with Inform.

Much of the Index is devoted to Inform’s Standard Rules. But as you
develop your story, your own code will be fully incorporated into the
Index. After writing some Instead rules and successfully compiling the
game, you’ll find these rules listed in the Instead rulebook under
Rules/Standards. Any extensions you have included in your game will also
be indexed.

Under the World tab, you’ll find a graphic map showing all of your
rooms and the connections among them. Inform’s attempt to map
complicated layouts is not perfect (nor could it be). In [WI 25.18](../WI_25.html#section_18), you’ll find some
suggestions on how to improve the map. After a bit of tweaking if
necessary, this map can be exported as an EPS file, as explained in
[WI 25.19](../WI_25.html#section_19). You may find this convenient, but my own
preference is to create a PDF map by hand using a freeware drawing
program such as OpenOffice.

## **Replacing Rules in the Standard Library**

If you open up the extension called the Standard Rules, you’ll find
the guts of Inform 7. Or at least, the higher-level guts; there’s a
lower level, as explained at the end of this Chapter, in the section
“What does Inform 6 Have to Do with Inform 7?” The Standard Rules are
not exactly light reading, but you can start to get a better idea of
what’s going on in Inform by skimming them. You’ll find, for instance,
this bit of code:

```
Check an actor taking (this is the can't take scenery rule):
	if the noun is scenery:
		if the actor is the player:
			say "[regarding the noun][They're] hardly portable." (A);
		stop the action. 
```


This is the rule that produces the output “That’s hardly portable” if
the player tries to take something that’s scenery. But let’s say you
don’t care for this message. The way to make such changes is
*not* to edit the Standard Rules file. You can edit this file if
you feel compelled to, but you’re inviting disaster. Inform provides a
more elegant solution. The rule above, like most of the rules in the
Standard Library, has a name. It’s called the can’t take scenery rule.
If you want to replace this rule, perhaps to produce a message that you
like better, here’s how to do it:

```
Check an actor taking (this is the new can't take scenery rule):
	if the noun is scenery:
		if the actor is the player:
			say "[regarding the noun][They're] not even faintly portable." (A);
		stop the action.

The new can't take scenery rule is listed instead of the  can't take scenery rule in the check taking rulebook.
```


If you only want to change the message for one particular scenery
object (or for a kind of scenery object), you can do it even more
easily:

```
Check an actor taking the boulder:
	say "You'd give yourself a hernia.";
	stop the action.
```


## Helping the Parser

Sometimes a word in your game will be ambiguous – that is, the parser
will be able to interpret it in two or three different ways. When
possible, you should use unique words to refer to every object in your
game, but sometimes that’s just not possible.

A handy trick for helping the parser deal with this type of ambiguity
is to write a Does The Player Mean rule. The way to do this is explained
  in [WI 17.19 Does the player mean…](../WI_17.html#section_19). Other useful techniques are shown in [WI 17.17 Context: understanding when…](../WI_17.html#section_17), [WI 17.20 Understanding mistakes](../WI_17.html#section_20), and [WI 17.21 Precedence](../WI_17.html#section_21). One of my favorite techniques (from [WI 17.17](../WI_17.html#section_17)) is writing Understand When
rules. We’ve seen a couple of these elsewhere in the *Handbook*.
Such a rule might look like this:

```
Understand "cracked" and "chipped" as the Ming vase when the Ming vase is broken.
```


When you put this rule in your code, the words “cracked” and
“chipped” will not be understood as referring to the vase if the vase is
not broken. Writing conditions that refer to specific scenes is also
useful:

```
Understand "dismantled" as the robot when Emergency Repairs is happening.
```


### Pronouns

Inform’s parser tries to make intelligent guesses about what the
player means when she uses words like “it”, “them”, and “him” in
commands. But occasionally this mechanism will go astray. In a few
cases, such a lapse can seriously confuse the player. Consider this
transcript:

{::options parse_block_html="false" /}
<div class="game-output">
<div class="command"><span class="prompt">&gt;</span>put bullet in revolver</div>
<p>You put the bullet into the revolver.</p>
<div class="command"><span class="prompt">&gt;</span>point it at dave</div>
<p>Nothing happens.</p>
<div class="command"><span class="prompt">&gt;</span>point revolver at dave</div>
<p>Dave backs away from you, saying, "No! No!"</p>

</div>
{::options parse_block_html="false" /}


In this case, the player understands that “it” is the revolver, but
the parser thinks “it” is the bullet. If the player only uses the
command containing “it”, she will conclude (erroneously) that Dave is
not intimidated by the loaded revolver. To solve this problem, you can
use the phrase “set pronouns from” in your code:

```
After inserting the bullet into the revolver:
	set pronouns from the revolver;
	continue the action.
```


## Clearing the Screen

Some authors like to clear the screen when a new section of the story
begins. This can be a nice effect if the player is teleported to an
entirely new time or place, for instance. You can get that
effect using [Basic Screen Effects by Emily Short](https://github.com/ganelson/inform/blob/master/inform7/Internal/Extensions/Emily%20Short/Basic%20Screen%20Effects.i7x):

```
Include Basic Screen Effects by Emily Short.

Instead of pushing the big red button:
	clear the screen;
	say "[line break]";
	say "You feel a brief tingling sensation…";
	move the player to Phobos;
	if the player does not wear the helmet:
		say "A little too late, you realize you've forgotten to don your helmet. There's no air on the surface of Phobos…";
		end the story saying "You have died.";
	else:
		stop the action.
```


The key command here is obviously, “clear the screen”; the rest is
just window dressing. This command is defined in Basic Screen
Effects.

The reason for putting in a line break after clearing the screen is
because some IF interpreters print the first line after a
clear-the-screen command behind the status bar (at the top of the
window), which will make it invisible. The line break will cause “You
feel a brief tingling sensation…” to appear reliably on all
interpreters after the screen has been cleared. Note, however, that if
your game creates a status bar with two lines of text, you’ll need to
use two line breaks.

## I6 Constants

As your game is compiled, Inform goes through two processes. First,
your source text and all of the extensions you’re using (plus the
Standard Rules) are turned into Inform 6 (I6) code. The I6 compiler then
runs, producing a playable .z8 or glulx game, depending on which format
you have chosen in the Settings tab. Occasionally, the compilation
process will stop at the second stage. This can happen for several
reasons, but one of the more common and less troublesome reasons is
because you’re using too much of something, and I6 thinks it’s running
out of room.

The Standard Rules define a series of constants, each of which
controls the amount of memory available in the game for a certain type
of data. Here’s the list:

```
  
Use ALLOC_CHUNK_SIZE of 32000.
Use MAX_ARRAYS of 10000.
Use MAX_CLASSES of 200.
Use MAX_VERBS of 255.
Use MAX_LABELS of 10000.
Use MAX_ZCODE_SIZE of 500000.
Use MAX_STATIC_DATA of 180000.
Use MAX_PROP_TABLE_SIZE of 200000.
Use MAX_INDIV_PROP_TABLE_SIZE of 20000.
Use MAX_STACK_SIZE of 65536.
Use MAX_SYMBOLS of 20000.
Use MAX_EXPRESSION_NODES of 256.
Use MAX_LABELS of 200000.
Use MAX_LOCAL_VARIABLES of 256.
```


<div class="addendum">

[Inform 6 version 6.36 and higher uses dynamic allocation during compilation](https://github.com/DavidKinder/Inform6/releases/tag/v6.36), rendering nearly all of these irrelevant. (Inform 7 10.1 is packaged with Inform 6 6.41.)

MAX_LOCAL_VARIABLES has become a constant (16 on the Z-machine, 119 on Glulx) and isn't subject to change. MAX_STACK_SIZE has potential relevance, as it has meaning for the resultant game, not just for compilation. Other things of continued relevance include:



  Use dynamic memory allocation of at least…
  Use maximum text length of at least…
  Use maximum things understood at once of at least…
  Use DICT_WORD_SIZE of…


</div>


If you receive a message from the compiler saying that one of these
values has been exceeded, all you need to do is write a line at the top
of your source code increasing it. (It goes without saying that you
should *never* edit the Standard Rules themselves.) For
instance:

```
Use MAX_STATIC_DATA of 360000.
```


With a large game, I’ve had to increase MAX_DICT_ENTRIES to 5000 to
make room for more vocabulary words. (MAX_DICT_ENTRIES doesn’t seem to
be in the Standard Rules. I have no idea where its default value is
defined.)

Increasing a value is easy to do – but you might be wondering, what’s
going on here? According to Inform guru Andrew Plotkin, MAX_STATIC_DATA
“is the compiler's workspace for array data. I7 uses this for tables,
and for storage space for relations, indexed text, dynamic lists, and
other on-the-fly work. The short answer is no, [needing to increase it]
shouldn’t alarm you; 360 kilobytes is  pocket change for computers these
days. On the other hand, a future Glulx interpreter running on a phone
or a Web browser might not be so  sanguine. If you’re doing something
which costs a huge amount of memory (such as a many-to-many relation),
and it’s not necessary [to your game], getting rid of it can only help
performance.”

## Relations

Relations are explained in [Chapter 13 of ](../WI_13.html)*Writing
with Inform*. They give Inform some extra power, but seeing how best
to use that power may not be easy. Relations can do at least two kinds
of things, and probably others – I haven’t used them much, so I’m not
sure.

First, relations can allow us to write about what’s going on in the
model world in ways that are shorter and easier to understand when
reading the code. Second, relations can be used to manage how bunches of
objects … well, how they relate to one another.

For a couple of examples of the first usage, see [WI 13.9: Defining new assertion
verbs](../WI_13.html#section_9). There, some new verbs are defined, which can then be used in
code. Here’s another example, this one my own:

```
Proximity relates a thing (called X) to a thing (called Y) when the holder of X is the holder of Y. The verb to jostle (he jostles, he jostled, it is jostled, he is jostling) implies the proximity relation.
```


If you need to make a decision in the game based on whether two
objects are in the same container, or on the same supporter, or in the
same room (directly in the room – on the floor), or carried by the same
person, you would normally write something like this:

```
if the holder of the apple is the holder of the orange:
```


But after creating a proximity relation as shown above, you can
simplify this test a bit by writing:

```
if the apple jostles the orange:
```


I’ve defined the word “jostles” using a relation. Any unused word
would serve – “snuggles” or “elbows”, for instance (but probably not “is
able to touch”, since Inform already knows how to test whether a
character “can touch” an object).

Various Examples in [Chapter 13 of ](../WI_13.html)*Writing with Inform* show
how the interactions among groups of people can be managed using
relations. These examples are worth studying in detail. If you’re
wondering whether it would be worth your while to spend the time on it,
here’s an imaginary example that may make the use of relations slightly
easier to understand.

Imagine a game in which the player plays the part of Cupid, complete
with bow and arrow. To win the game, you need to shoot Jason with an
arrow, shoot Jennifer with an arrow, and then get Jason and Jennifer
into the same room so that they fall in love.

If they wander into the same room, the software will need to be able
to figure out whether each of them has been shot with an arrow and is
ready for love. That’s the easy part. All we need to do is write a few
assertions along the lines of “A person can be ready-for-love.” If Jason
has been shot and is ready-for-love, he’ll fall in love with Jennifer
when he sees her (assuming we write code that will make him do so). But
Jennifer might not have been shot yet, so she might not fall in love
with Jason when she sees him.

There’s no real need to use relations to manage this game. You can do
something simple, with properties, like this:

```
Jason can be ready-for-love or not ready-for-love. Jason can be loving-Jennifer or not loving-Jennifer.
```


…and similar properties for Jennifer. When Jason is loving-Jennifer
and Jennifer is loving-Jason, the player has won the game. We don’t need
relations here, because these two properties will do the job nicely.

But now imagine that the game includes Steve, Bill, Ted, Ralph, and
Jason; and also Jennifer, Susan, Beth, Amy, and Helen. Any one of them
can fall in love with any of the others, and vice-versa! If we try to use properties, the list of
properties each character will need is going to be rather long, and
managing these properties in such a way as to avoid bugs will be quite
tricky. To manage the potential romantic tangles that can arise during
the game in a more reliable way, a better approach will be to use
relations.

The code for this game would almost certainly include the example
sentence in [WI 13.5: Loving relates various people to
one person](../WI_13.html#section_5). We would have to write more code in order to cause
characters who have been shot with one of Cupid’s arrows to fall in love
with the next suitable person they see. I’m not going to do that here,
but it’s not actually a bad idea for a game. I hope someone will try it.
Once a character is ready-for-love and sees an appropriate romantic
object, all we need to write is:

```
now Steve loves Susan;
```


If Steve has previously been in love with Amy, that one line of code
will automatically make him fall out of love with Amy, because the
statement “Loving relates various people to one person” allows a person
to love only one other person at a time. That’s the power of relations:
Relations can manage the various combinations a lot more easily.

If you’re using relations in your game, you can take advantage of the
debugging command RELATIONS, which prints out a list of all the
relations that are currently active among the objects in your game.

Here’s a more complete (and more practical) example of how to use
relations. In this short game, we want the player to have to stand on a
chair in order to touch the chandelier. But it’s not enough to stand on
the chair: The chair has to be positioned correctly beneath the
chandelier. In addition to a new action (putting it beneath), we need to
define a relation that will keep track of whether something is beneath
something else. Whenever the player picks up an object, we need to get
rid of the relation. And just to keep things tidy, we’ll also create a
new property, high or low. The player will only be able to put things
beneath things that are high. In a game where the player is allowed to
put a coaster underneath a glass, or a silver dollar underneath a sofa
cushion, the high/low property might get in the way, and the rules for
the putting it beneath action would naturally be more complicated. But
this example could easily be adapted so as to force the player to put a
chair beneath a high shelf in order to get something off of the shelf,
for example.

```
A thing can be high or low. A thing is usually low.

The Living Room is a room. "A large, old-fashioned room lit by a crystal chandelier."

The crystal chandelier is scenery in the Living Room. The description is "It shimmers with light." The chandelier is high.

The chair is an enterable supporter in the Living Room. It is not fixed in place. The description is "A sturdy chair[if the chair is near the chandelier]. It's positioned directly beneath the chandelier[end if]."

Proximity relates things to each other. The verb to be near implies the proximity relation.

Putting it beneath is an action applying to two things and requiring light. 

Understand "put [something] underneath/beneath/under [something]", "push [something] underneath/beneath/under [something]", "place [something] underneath/beneath/under [something]", "set [something] underneath/beneath/under [something]", and "position [something] underneath/beneath/under [something]" as putting it beneath.

Check putting it beneath:
	if the second noun is not high:
		say "[The second noun] lack[if the second noun is not plural-named]s[end if] the requisite elevation." instead.

Carry out putting it beneath:
	now the noun is in the location;
	now the noun is near the second noun.

Report putting it beneath:
	say "You place [the noun] on the floor directly beneath [the second noun]."

Instead of putting the chair beneath the chandelier:
	if the chair is near the chandelier:
		say "The chair is already beneath the chandelier.";
	otherwise if the player is on the chair:
		say "You'll have to get off of the chair if you want to do that.";
	otherwise:
		if the player carries the chair:
			move the chair to the location;
		now the chair is near the chandelier;
		say "You place the chair beneath the chandelier."

After taking something:
	if the noun is near a thing:
		now the noun is near nothing;
	continue the action.

Check touching the chandelier:
	if the player is not on the chair:
		say "You can't reach it." instead;
	otherwise if the chair is not near the chandelier:
		say "It's out of reach. Maybe if you put the chair underneath the chandelier first, you could reach the chandelier." instead.

Report touching the chandelier:
	say "The crystal is cool to the touch, and a little dusty. The entire chandelier sways gently as your fingers brush it, and makes a soft, musical tinkling sound.";
	rule succeeds.

The player carries a bowling ball. [For testing purposes.]

Test me with "touch chandelier / stand on chair / touch chandelier / get off / put chair under chandelier / stand on chair / touch chandelier / put ball under chandelier / relations".
```


## Adding Hints

My personal belief (some people don’t agree) is that almost any work
of IF that includes puzzles should have a complete set of built-in
hints. The bad thing about hints is that they can make it too easy for
the player. Instead of exercising her brain-power, she can just look up
a hint, slam through the puzzle, and move on to the next part of the
game.

On the other hand, a player who gets stuck in the middle of a game
and has no way of getting unstuck may just set the game aside and never
come back to it. If you care about having players enjoy your game from
start to finish, I hope you’ll at least consider providing a hint menu.
It’s a little extra work, but many players will appreciate it.

A well-written series of hints will first nudge the player gently
toward the solution of each puzzle. If the player asks for more hints,
they’ll become broader and more obvious. The last hint in each list
should provide a complete, step-by-step solution to the puzzle. If
you’re tempted to write just a couple of hints for each puzzle and then
stop by saying something like, “Well, it should be obvious to you by
now,” I hope you’ll consider that some of your players may want to shoot
you. This can’t be viewed as a desirable outcome.

On the other hand, it’s sporting to offer the player a chance to
disable the hints so as not to be tempted.

A good extension to use for adding hints to your game is [Adaptive
Hints by Eric Eve](https://github.com/i7/extensions/blob/10.1/Eric%20Eve/Adaptive%20Hints-v7.i7x). While the commands the player uses to navigate the
hint system are clumsy, the functionality is there. The documentation
for this extension is thorough and easy to follow, so there’s no reason
to discuss it here. One nice thing about Adaptive Hints is that the
contents of the Hint menu can be changed during the course of the game.
This helps prevent “spoilers.” For instance, if the player consults the
hints early in the game, it would be a terrible spoiler to find a hint
listed as “How do I get the jewels out of the stomach of the shark?”
before the player has encountered a shark or knows about the jewels.
Using Adaptive Hints, you can cause that hint to appear only after the
player has reached a point in the game where it makes sense for the hint
to be available. To keep track of whether the player has seen the shark
or knows about the jewels, [Epistemology by Eric Eve](https://github.com/ganelson/inform/blob/master/inform7/Internal/Extensions/Eric%20Eve/Epistemology.i7x) is the tool of
choice.

## Special Features in Glulx

In [WI Chapter 23: Figures, Sounds and Files](../WI_23.html), you’ll find a good discussion of how to add
graphics files (digital photos or clip art in .jpg or .png format) to
your game. To do so, you’ll need to compile to glulx, not to .z8.

Displaying graphics in a game can be a good way to give the game an
extra dimension – but not all IF interpreters will display graphics.
Some interpreters are *text-only.* In addition, some IF players
are blind or visually impaired. One of the reasons these folks like IF
is because they can play the games using screen-reader software. For
these reasons, it’s probably not a good idea to write a puzzle in such a
way that an essential clue is found only in a graphic image. Think of
graphics as enhancements.

The same chapter in the Documentation also discusses including sound
files briefly. But again, you’ll be at the mercy of the interpreter the
player happens to be using. Support for sound playback in IF is
generally not too reliable, so I’d suggest not worrying too much about
this feature.

The glulx game format also supports opening several windows at once
within the interpreter’s main window. With this feature, you could
display graphics in one sub-window and have the text game running in
another sub-window. Instructions on how to use this feature are beyond
the scope of this *Handbook.*

The current version of the Glulx specification is very limited when
it comes to text styles. Emily Short’s extension Glulx Text Effects does
a nice job of illustrating what’s possible.

## What Does Inform 6 Have to Do with Inform 7?

In this *Handbook*, I’ve deliberately avoided getting too far
into the deep end of Inform programming. If you work with Inform 7 for a
while, though, you’ll start to see occasional mentions of Inform 6.

In a technical sense, Inform 7 is built “on top of” Inform 6. Inform
6 is still being used behind the scenes when your game is compiled. But
this fact is normally well hidden from the I7 programmer, and there’s no
reason why most authors need to concern themselves with it.

Once in a while, an expert programmer will want to achieve an effect
that can only be achieved by including some I6 code in an I7 game. If
you look at the code in a few extensions written by experts, you’ll
probably see Inform 6 peeking through the curtain. Here’s a line from an
extension by Emily Short that I chose at random:

```
Use direct event handling translates as (- Constant DIRECT_GLK_EVENT_HANDLING; -).
```


The parentheses and hyphens are what tells the compiler “Here’s some
Inform 6 code.” What that particular line does … I don’t know, and it
doesn’t matter. For more details on how Inform 6 code can be included in
Inform 7 code, you can look at [WI 27.14: Using
    Inform 6 within Inform 7](../WI_27.html#section_14)
  through [WI 27.24: Inform 6
adjectives](../WI_27.html#section_24). But the things you can do
with I6 code are far beyond the scope of this *Handbook*.

Think of it this way: Writing a game in Inform 7 is like driving a
car down the road. Adding I6 code to an I7 game is like pulling over,
popping the hood, and tinkering with the fuel pump. Once in a while,
that may be the only way to get where you want to go, but you shouldn’t
need to do it too often, and nobody but an expert mechanic should try it
at all.

## So, Is Inform 7 the Ultimate IF Programming Language?

Given the popularity of Inform 7 and the ease with which newcomers
can use it to start creating their own interactive fiction, it wouldn’t
be surprising if people get the impression it’s the best IF development
system that could ever be imagined. It would be wrong for this
*Handbook* to draw to a close without commenting on that
impression.

For all its strengths, Inform has some surprising weaknesses, some of
them trivial, others a bit more awkward to deal with. A few of them have
been touched on in the course of this book. Obviously, I feel that
Inform is a very good language with which to approach writing
interactive fiction, especially if you’re new to computer programming.
But my enthusiasm has more to do with Inform’s approachability – its
“natural language” syntax and its cross-platform IDE – than with the
nuts and bolts of its design.

Some of its limitations seem to have arisen out of Graham Nelson’s
desire to preserve backward compatibility with older IF systems – not
just Inform 6 but earlier systems dating back to the 1980s, when Infocom
was still an active company releasing new text-based games. The fact
that a game’s release number (displayed in the banner at the beginning
of the game) can’t have decimal places, but can only be an integer,
seems to have no rational basis other than the fact that that’s how
Infocom did it. Today, the standard in version numbering often includes
not one but two decimal points – version 1.5.2, for instance. Inform
just plain can’t number your game’s version that way.

To be sure, that’s a trivial issue. A more serious example is the
separation between .z8 game files on the one hand and Glulx files on the
other. The Z-machine format is an artifact of a bygone era. In those
days, computers typically had less than a megabyte of memory, so the .z8
format simply can’t be used with large files. There’s no real reason why
this format should still be supported today, except for the large
installed base of Z-machine interpreters. On the other hand, the
Z-machine is actually more powerful than a Glulx interpreter in a few
restricted circumstances having to do with type styles; Glulx is, at
this writing, still rather poor at allowing the author to create a
variety of new type styles.

Other limitations or odd design choices seem to have arisen due to
the piecemeal fashion in which Inform was developed. Because its syntax
is very unlike the syntax of any other programming language, and because
Nelson wanted the code to read as much like English as possible, he
seems to have made some choices along the way that were less
systematically consistent than *ad hoc*. If you’ve created a
backdrop called the sky, for instance, you’ll find that in some code
statements you can refer simply to “the sky”, while in others you have
to refer to “the sky backdrop,” as explained in [WI 8.8](../WI_8.html#section_8).

The fact that doors can’t be moved probably simplifies the way Inform
works internally, but in terms of the limitations it places on the
author, it was a poor design choice. No more need be said about
that.

Another limitation, and one that is of concern to a lot of authors,
is that Inform insists that all of the code for your game be stored in a
single file. No other modern programming language operates this way; the
norm among programmers is to store the code for a single project in
several files, which can be edited (and compiled) separately. There are
several reasons why forcing all the code for a game to live in a single
file was a debatable design choice: It makes collaborating with other
authors more difficult, it makes editing more difficult, and so on. The
fact that the code file is always called story.ni can also become a
problem, because it makes the process of archiving successive versions
of a single project during development a bit more cumbersome and
error-prone than it needs to be.

At the code design level, Inform doesn’t allow multiple inheritance.
For instance, a single object can’t be both a device and a supporter.
Lacking the ability to create such an object, the author has to choose a
workaround in order to create as standard an in-game object as a stove.
The workarounds are not, in most cases, difficult to work with. Usually,
you can make one object a part of another object, and you’ll be ready to
move on. For that matter, Inform’s device class is so bare-bones that
there’s almost no reason to use it at all. But the absence of multiple
inheritance can occasionally force the author to perform a few
gyrations.

If you want to really master the deepest level of Inform 7
programming, you’ll have no choice but to learn an entirely new and much
more abstract set of code syntax: Inform 6. Learning two separate coding
systems means extra work. To be sure, Inform is not the only computer
language that works this way: Musicians who use Csound, for instance,
can get at some of its deeper features only by learning to program in
Python or C. But most interactive fiction authoring systems are not
bifurcated in this way. TADS 3 can be entirely customized by writing new
code that uses exactly the same syntax you would use to write your game
(though the extensive use of macros and templates in game programming
somewhat obscures this fact). TADS has a much more extensive built-in
library than Inform, implements multiple inheritance, and handles type
styles, clickable hyperlinks, and multimedia. (Also, the TADS Workbench
has tools for professional-level debugging, such as stepping through the
code one line at a time. On the other hand, Workbench is a Windows-only
program. To use it on a MacOS or Linux computer, you have to run a
Windows emulator.)

In sum – no, Inform 7 is not the be-all or end-all. Even so, there’s
no denying that it’s powerful, popular, well-supported, and quite easy
to use, and has a number of terrific features. For many aspiring
authors, it will be absolutely the right choice. Because it’s still
being developed, certain of the issues mentioned in this concluding
section of the 2009 edition of the *Handbook* have already been
dealt with. And the developers of extensions for Inform have added, and
continue to add, some powerful and unexpected capabilities. If you’re
new to writing IF, you need have no fear that in choosing Inform 7,
you’re painting yourself into a corner or headed down a dark alley. You
can have confidence that you’re making a wise choice, that you’ll be
able to produce games of amazing complexity and high quality.

All it takes is thick slabs of inspiration and months of hard work,
coupled with generous amounts of head-scratching, hair-pulling, and
teeth-grinding. Really, you hardly ever need to throw your computer
across the room in sheer frustration. Once in a while, you may notice
that you’re actually having fun. And that’s the point, isn’t it?
