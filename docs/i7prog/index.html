<!doctype html>
<html lang="en"><head><meta charset="utf-8">
<title>Inform 7 for Programmers</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,375;0,400;0,500;0,700;1,375;1,400;1,500;1,700&family=Source+Sans+Pro:ital,wght@0,350;0,400;0,550;0,700;1,350;1,400;1,550;1,700&display=swap" rel="stylesheet"> 
<link rel="stylesheet" href="../i7doc.css">
<link rel="stylesheet" href="i7prog.css">
  </head>
  <body>
<main>
    <heading>
<h1 class="title" id="inform-7-programmers-manual">Inform 7 Programmer's Manual</h1>

<div class="subtitle">Ron Newcomb<br>August 15, 2011<br>build 6G60</div>

<h2>Contents</h2>
<ul class="contents" role="list">
<li><a class="raw" href="#inform-7-in-a-nutshell">Inform 7: In a Nutshell</a></li>
<li><a class="raw" href="#the-firehose">The Firehose</a></li>
<li><a class="raw" href="#class-and-prejudice">Class and Prejudice</a></li>
<li><a class="raw" href="#the-coding-imperative">The Coding Imperative</a></li>
<li><a class="raw" href="#boolean-adjectives">Boolean Adjectives</a></li>
<li><a class="raw" href="#patterned-procedures">Patterned Procedures</a></li>
<li><a class="raw" href="#functions-decide-on-a-value">Functions Decide on a Value</a></li>
<li><a class="raw" href="#say-phrases">Say Phrases</a></li>
<li><a class="raw" href="#types-of-types">Types of Types</a></li>
<li><a class="raw" href="#sweet-relations">Sweet Relations</a></li>
<li><a class="raw" href="#rules-of-thumb">Rules of Thumb</a></li>
<li><a class="raw" href="#rulebooks-white-box-paradigm">Rulebooks: White-box Paradigm</a></li>
<li><a class="raw" href="#events-are-actions">Events are Actions</a></li>
<li><a class="raw" href="#understanding-our-player-our-parser">Understanding Our Player, Our Parser
<li><a class="raw" href="#arrays-have-been-tabled">Arrays Have Been Tabled</a></li>
<li><a class="raw" href="#time-for-a-scene">Time for a Scene</a></li>
<li><a class="raw" href="#named-values-everywhere">Named Values Everywhere</a></li>
<li><a class="raw" href="#its-not-just-text">It's Not Just Text</a></li>
<li><a class="raw" href="#precisely-one-spoon-unit-of-sugar">Precisely One Spoon-unit of
<li><a class="raw" href="#backstage-activities">Backstage Activities</a></li>
    <ul><li><a class="raw" href="#activities-looking">Looking</a></li></ul>
<li><a class="raw" href="#testing-commands">Testing Commands</a></li>
<li><a class="raw" href="#times-turns-and-tenses">Times, Turns, and Tenses</a></li>
<li><a class="raw" href="#swapping-headings">Swapping Headings</a></li>
<li><a class="raw" href="#facing-inform-6">Facing Inform 6</a></li>
<li><a class="raw" href="#ready">READY.</a></li>
</ul>
</heading>
<h2 id="inform-7-in-a-nutshell">Inform 7: In a Nutshell</h2>
<p>Inform 7 is a domain-specific language intended for authoring
interactive fiction in the vein of Zork and Colossal Cave. Just as the
videogame industry in general strives for better story in its products,
Inform 7 strives to appeal to creators who are not programmers, and
certainly do not have a collegiate background in computer programming
with all of the vocabulary and metaphors that that entails. In this way,
Inform 7 shares aims with BASIC, COBOL, and Applescript: a readable
language for the intelligent layperson. But Inform takes readability
much further.</p>

<p>This chapter compares Inform with other programming languages to give
the seasoned programmer a sense of place. It can be skipped if so
desired, though the rule breakdown at the end may be useful to return to
later.</p>

<p>Inform does not concern itself about optimizing compilation speed at
the expense of syntax, or ensuring scalability and security at the
expense of complexity. Several design choices seem unusual or even a bad
idea at first blush, but they are based on several years' worth of
experience in creating interactive fiction. The first two of these
choices will be much on your mind while learning. The other two will
eventually befriend you.</p>

<p>First: identifiers may have spaces. Avoiding the
underscore-or-capitalize convention, in Inform 7 one could name a
variable "the currently owned car". Likewise for all other constructs in
the language, including functions: <strong>"mull over</strong> (idea -
an object) <strong>in my</strong> (spot - a room)<strong>"</strong>.
Extraordinarily readable code results when constructs are named
appropriately: objects and value-returning functions after noun phrases,
actions and activities after participial phrases, non-value-returning
functions after imperative sentences, etc. Articles <em>a</em>,
<em>an</em>, and <em>the</em> are almost always ignored.</p>

<p>And second: rulebooks. Inform 7 is a rulebook-based language. A
rulebook is a container for rules, but these are not the production
rules from Prolog. Rather, they are unnamed imperative functions that
self-invoke based on global variables, game-state, and most importantly,
on whether the containing rulebook is executing. From the outside, a
rulebook acts &ndash; and is invoked &ndash; like a function: give it a task and
it will solve it. The difference is how it solves it. It may execute
every applicable rule within itself, or may only execute the most
specific applicable rule, your choice. The entirety of the Inform 7
system is a sequence of rulebooks in a prescribed order, with the
oft-ignored background ones calling the numerous foreground rulebooks,
and the foreground ones, initially empty, containing dozens of author-
written rules.</p>

<p>Third are adjectives, especially as used by set-descriptions. An
adjective is a boolean, but when combined with the class or construct to
which they belong, they describe a set of instantiations. Consider this
common loop construct, keywords being in bold: "<strong>repeat
with</strong> antagonist <strong>running through</strong> unhappy
resourceful people". The index variable will be "antagonist". Person is
a class, while unhappy and resourceful are boolean values for two
different properties or methods. The loop will set antagonist to each
person in turn whose adjectives are set in the indicated way. Inform
recognizes plural words as synonymous.</p>

<p>Finally are relations. Object-oriented programming is built on two
asymmetric relations, is-a and has-a. Inform allows creation of binary
relations between almost any two constructs in the language, including
text strings. Like adjectives, relations are either-or: either the
friendship relation holds between two person instantiations or it
doesn't. Moreover, many constructs can check a relation, the repeat loop
being the simplest: "<strong>repeat with</strong> ally <strong>running
through</strong> resourceful people which are friends with the
player".</p>

<p>Of all programming languages, Inform 7 currently most resembles
natural language. Knuth's ideas of literate programming reinforce this,
as evidenced by the official website, Inform7.com. Terminology useful in
describing Inform 7 follow.</p>

<p><strong>Domain-specific.</strong> It compiles to a virtual machine
not used outside of the interactive fiction community, and rules are
restricted to three parameters: the highest arity a verb of English may
have.</p>

<p><strong>Event-based.</strong> Events are called "actions" because the
game player's commands trigger protagonist actions in the simulated,
turn-based gameworld.</p>

<p><strong>Object-based.</strong> Single-inheritance and polymorphism
are supported, but abstraction, modularity, and namespaces are poor to
absent. Inform 7 is a white-box development language by design.
Scalability and security are of no concern.</p>

<p><strong>Macro language.</strong> Technically, Inform 7 is a macro
language for Inform 6, a weakly-typed multiple-inheritance traditional
programming language. All Inform 7 code becomes Inform 6 code before
Inform 6 compiles to the virtual machine's assembly. The dev team takes
care to hide this complication from novice users, but inline Inform 6
code, as well as inline VM assembly, can be used to powerful effect.</p>

<p><strong>Strongly typed.</strong> You'll swear you're in Pascal again,
but the type system supports generic types and type variables. When all
else fails, inline Inform 6 code will circumvent.</p>

<p><strong>Statically allocated.</strong> Although extensions can be
installed to circumvent this, and text modified at runtime skirts it,
Inform's motto is "one pointer, one block". This greatly simplifies
things for the target audience even if all the deep copying slows na√Øve
code.</p>

<p><strong>Pronounceable, Type-able.</strong> Perhaps voice-recognition
input methods for coding will one day become the norm. Until then, you
can transcribe Inform code over your friend's telephone. Additionally,
the Dvorak keyboard layout optimizes the placement of letters, which
Inform makes almost exclusive use of. Dvorak doesn't do much for
punctuation, which traditional languages favor.</p>

<p><strong>Eschews One True Construct.</strong> Some languages can say
"everything is an object" or "everything is a list". Inform does not
have One True Construct, though the powerful type system can bring
objects, enums, rules, etc. under the same umbrella for the same effect
as having a common parent class. Theoretically, the lack of a unifying
construct eases learning as each construct can be learned independent of
anything else, and constructs implement themselves however makes
sense.</p>

<p><strong>Easy To Read, Hard To Write.</strong> Empirically, Inform has
proven to be easy to read but hard to write. The natural language
appearance can be a will-o-wisp at times, luring the author from the
path of clear grammar, as there are many phrasings that Inform "ought"
to recognize, but does not. Conversely, creating uncommented code
beautiful enough to be worth publishing is a viable sport. Such code can
deliver its meaning even to those who aren't programmers.</p>

<p><strong>Semantic Concision.</strong> Inform boasts some unique
semantic conciseness on top of its extreme readability, which will
hopefully be emulated in programming languages to come. For example,
this is a single rule from a particular game.</p>

<div class="codeblock">
<div class="codeline">Instead of a suspicious person (called the suspect) burning something which is evidence against the suspect when the number of people in the location is at least two, try the suspect going a random valid direction.</div>
</div>

<p>That rule breaks down like this.</p>

<p><ul role="list">
<li><strong>"Instead"</strong> is the rulebook which owns the rule. The rulebook's name comes first, and there's precisely one of them.</li>
<li><strong>"of"</strong> is one of the many ignored prepositions allowed in that place, for readability.</li>
<li><strong>"a"</strong> is an article, and ignored.</li>
<li><strong>"suspicious"</strong> is an adjective on class Person.</li>
<li><strong>"person"</strong> is the class of the first parameter to the burning action.</li>
<li><strong>"(called the suspect)"</strong> names the first parameter so we can reference it elsewhere in the rule.</li>
<li><strong>"burning"</strong> is the action, the event, usually triggered by the player entering "BURN EVIDENCE". It takes two parameters, of types Person (the actor) and Thing.</li>
<li><strong>"something"</strong> is synonymous with "a thing" just as "someone" is synonymous with "a person". It is class Thing.</li>
<li><strong>"which"</strong> flags that we're using a relation to narrow down what Things may trigger the rule.</li>
<li><strong>"is evidence against"</strong> is a many-to-many relation, thing-to-person. Contrast the number-to-number "is less than".</li>
<li><strong>"the suspect"</strong> is to what we're relating, which in this case is the first parameter.</li>
<li><strong>"when"</strong> is synonymous with "if", but is used in rule preambles while "if" is used in imperative code blocks.</li>
<li><strong>"the number of"</strong> is a function that will count the members in the following set-description.</li>
<li><strong>"people"</strong> is, again, a name for class Person.</li>
<li><strong>"in the location"</strong> is a shortcut phrase for a person-to-room relation wherein the person is always the player.</li>
<li><strong>"is at least"</strong> means equal to or greater than. If the suspect is alone, our rule won't apply.</li>
<li><strong>"two"</strong> can be written as 2, but Inform is unusual in that digits tend to stick out like sore thumbs.</li>
<li><strong>","</strong> the comma ends the rule preamble and begins the imperative code block. Frequently a colon must go here.</li>
<li><strong>"try"</strong> will initiate a new action, and the whole sequence of rulebooks that that entails. In this case, the Going action will be called.</li>
<li><strong>"the suspect"</strong> will apparently try a new tack in destroying the self-incriminating evidence he's holding, because he's not alone.</li>
<li><strong>"going"</strong> takes two parameters, of types Person and Direction.</li>
<li><strong>"a random"</strong> chooses one member out of a set-description. The following two words define this particular set of instantiations.</li>
<li><strong>"valid"</strong> is an adjective on class Direction. It is rare the room that has exits in every direction!</li>
<li><strong>"direction"</strong> is a class. The twelve standard instantiations are the eight compass points plus Up, In, Down, and Out.</li>
<li><strong>"."</strong> the period ends the rule. So would a blank line.</li>
</ul></p>

<p>Rule preamble constructs like <em>someone hungry eating something
edible</em> are not action invocations &ndash; that would be <em>try Mario
eating a mushroom</em> &ndash; and not action definitions &ndash; multiple
rulebooks do that &ndash; but rather, they are very much like a regex,
applied to the state of the whole work rather than to a piece of
text.</p>

<p>Excepting the automatically included Title and Author line on the
first line of the source, the Hello World program is this.</p>

<div class="codeblock">
<div class="codeline">My apartment is a room.</div>
<div class="codeline">When play begins, say "Hello world."</div>
</div>

<p>Every program must have at least one instantiation of class Room,
which is where the virtual action takes place. (So the smallest program
that will compile is: <em>Foo is a room.</em>) Comments belong in square
brackets, and the IDE will color them green.</p>

<p>A final note: In this guide as well as in Inform's official
documentation, "the parser" always refers to the runtime parser, our
player's simplistic VERB NOUN PREPOSITION NOUN parser. It does not mean
that part of the Inform 7 compiler itself.</p>

<h2 id="the-firehose">The Firehose</h2>

<blockquote>
<p>"Information is gushing toward your brain like a firehose aimed at a
teacup."</p>

<p style="text-align: right;">&ndash; Scott Adams, cartoonist, on the complexities of modern life
(1996)</p>
</blockquote>

<p>Because Inform 7 source is not cryptic, I don't feel we need much
exposition before showing source code. It is fairly easy to see what any
natural language-inspired programming language is trying to accomplish
simply by reading source. The difficulty with learning Inform 7, besides
the whole rulebook thing, will be trying to see the grammar and types
behind the pretty fa√ßade so you can actually write it. So in this
chapter, The Firehose, we go on a whirlwind tour of the language reading
code samples and mapping common constructs into Inform. For brevity, the
very first automatically-added line of the source which has the work's
title and author won't be shown in this guide.</p>

<div class="codeblock">
<div class="codeline">The apartment is a room. "Behold Bob's apartment. That smell is coming from the pile of dishes in the sink."</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">The apartment complex's lobby is south of the apartment. "Rows of mailboxes are set into the lobby wall. Box 114 is Bob's."</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Mr Bob Dobalena is a man in the apartment. "Bob sports a well-loved Transformers t-shirt with acid-washed jeans."</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">T-shirt, jeans, and a pair of shoes are wearable things.</div>
<div class="codeline">Bob is wearing the shoes, the T-shirt, and the jeans.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Instead of examining the player, say "You've come to visit your old college friend, Bob, and are standing in [the location]."</div>
</div>

<p>We have two Room instances (<em>apartment</em> and <em>apartment
complex's lobby</em>), one Man instance, and three Thing instances
(<em>T-shirt</em>, <em>jeans</em>, <em>pair of shoes</em>) with their
boolean <em>wearable</em> property set to true. The quoted text that's
just floating by itself out there becomes the <em>initial
appearance</em> property of Thing and its subclasses, or for anything
else, the <em>description</em> property (not to be confused with the
set-description type.) There's a few relations in there as well. The
mapping-south relation ties the two rooms together, and must exist for
<em>going</em> events on the obvious <em>direction</em> instance. By
default, the mapping-north relation is also sensibly set. The wearing
relation is thrice asserted to hold between Bob and each article of
clothing. Finally, the <em>instead</em> rule changes the behavior of the
Examine event, our player's command EXAMINE ME, which typically prints
"As good looking as ever."</p>

<p>The source accomplishes a lot with little writing. One sentence
instantiated three Things &ndash; the three pieces of clothing "are &hellip;
things" &ndash; and set a boolean property on them at the same time &ndash; all
three pieces are "wearable things". The next sentence simultaneously set
three relations, between Bob and each article of clothing. Object names
can be abbreviated (<em>Bob</em>, <em>shoes</em>).</p>

<p>The text that's printed in response to examining fills in the name of
whichever room the player is standing in.</p>

<p>Next we'll show variable declarations of every major type. For now,
know that <em>is</em> and <em>are</em> are perfectly synonymous and the
articles <em>a</em>, <em>an</em>, and <em>the</em> are simply stripped
from the source.</p>

<div class="codeblock">
<div class="codeline">X <strong>is</strong> <em>a number</em> <strong>that varies</strong>.</div>
<div class="codeline">Y <strong>is</strong> <em>a number</em> <strong>variable</strong>.</div>
<div class="codeline">Deadline <strong>is</strong> <em>a time</em> <strong>that varies</strong>.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">An excuse <strong>is</strong> <em>some text</em> <strong>that varies</strong>.</div>
<div class="codeline">My favorite toy <strong>is</strong> <em>a thing</em> <strong>that varies.</strong></div>
<div class="codeline">&thinsp;</div>
<div class="codeline">The current manager <strong>is</strong> <em>a person</em> <strong>that varies</strong>.</div>
<div class="codeline">The ocean currents <strong>are</strong> <em>a direction</em> <strong>that varies</strong>.</div>
<div class="codeline">The best spot <strong>is</strong> <em>a room</em> <strong>that varies.</strong></div>
<div class="codeline">&thinsp;</div>
<div class="codeline">The light switch's boolean <strong>is</strong> <em>a truth state</em> <strong>that varies</strong>.</div>
<div class="codeline">The guru's answers <strong>are</strong> <em>a table name</em> <strong>that varies</strong>.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">My secret plans <strong>are</strong> <em>a rulebook</em> <strong>that varies.</strong></div>
<div class="codeline">&thinsp;</div>
<div class="codeline">What worked last time <strong>is</strong> <em>a rule</em> <strong>that varies.</strong></div>
<div class="codeline">&thinsp;</div>
<div class="codeline">My regex target <strong>is</strong> <em>some indexed text</em> <strong>that varies.</strong></div>
<div class="codeline">&thinsp;</div>
<div class="codeline">An abeyance <strong>is</strong> <em>a stored action</em> <strong>that varies.</strong></div>
</div>

<p>And now some examples of supplying initial values. <em>Usually</em>
defines a default value that can be overridden by a specific
<em>is</em>. <em>Usually</em> is very useful for creating class
properties with a default value, which specific instances can override
at compile-time. Same goes for globals.</p>

<div class="codeblock">
<div class="codeline">X <strong>is</strong> usually 2.</div>
<div class="codeline">Y <strong>is</strong> 5.</div>
<div class="codeline">Deadline <strong>is</strong> usually 4:30 pm.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">The excuse <strong>is</strong> usually "I don't know"</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">My favorite toy <strong>is</strong> usually the red Ferrari.</div>
<div class="codeline">The current manager <strong>is</strong> Bob.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">The light switch's boolean <strong>is</strong> usually true.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">The guru's answers <strong>are</strong> usually the table of deep answers.</div>
</div>

<p>Learning to write rules for the various player-generated events
(<em>actions</em>) and library events (<em>activities</em>) is core. The
rule's preamble is much like a regex on the state of the game, while the
rule body is simply imperative code. All rules belong to a rulebook, and
the rulebooks a game author usually writes action rules for are, in
order of execution, <em>before</em>, <em>instead</em>, <em>check</em>,
<em>carry out</em>, <em>after</em>, <em>report</em>, and <em>every
turn</em>. Some of the usual player actions are: <em>looking</em>,
<em>examining</em>, <em>taking</em>, <em>dropping</em>, <em>taking
inventory</em>, <em>going</em>, <em>opening</em>, <em>closing</em>,
<em>inserting it into</em>, <em>putting it on</em>, <em>removing it
from</em>, plus a few system-level ("out of world") actions such as
<em>saving the game</em>, <em>restoring the game</em>, and <em>quitting
the game</em>. By default, an <em>instead</em> or <em>after</em> rule
will cause execution to hop immediately to <em>every turn</em>, and a
<em>check</em> rule is expected to do the same though by default it does
not. Out of world actions only use the <em>check</em>, <em>carry
out</em>, and <em>report</em> rules, and sometimes not even all of
those. For example, once <em>quitting the game</em> is carried out, the
software is no longer running to report anything.</p>

<p>It is easier to show all parts of a full rule preamble than explain
each part in turn, rather than starting with simpler preambles and
working one's way up. Ready your teacup.</p>

<div class="codeblock">
<div class="codeline">A check rule for an actor inserting my favorite toy into the jeans when the time of day is before the deadline:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "[The current manager] would fire [the actor] for stuffing [my favorite toy] down there!" instead.</div>
</div>

<p>Syntax requires the rulebook name first, excepting articles like
<em>a</em> which are practically whitespace. Here we use <em>check</em>.
Rulebook names can be one word or many, and tend to be or start with
either an imperative verb (check, carry out, report) or a subordinating
conjunction (before, after, instead). That isn't required, but it reads
better because actions are always a present participle (the -ing form of
a verb). Rulebooks which don't typically hinge on an action, such as
<em>every turn</em>, are named to stand alone, or mesh well with
<em>when</em> or <em>while</em> which usually follows their name.</p>

<p>Next can be some optional words: <em>rule</em>, <em>for, of</em>.
They do nothing except improve the flow of reading. Here we used both
<em>rule</em> and <em>for</em> only for the sake of an example.
<em>Instead</em> almost always uses <em>of</em>, but normally, we would
have begun <em>Check an actor&hellip;</em></p>

<p>Anyway, after the rulebook name is, optionally, the performer. Here
we used <em>an actor</em> so the rule applies to all characters, not
just the player. (The <em>an</em> is one of the few times when a
particular article is required.) Other options are 2) omit it entirely,
so the rule only applies to the player; 3) a specific named character
such as Bob, provided Bob is not the player; 4) a set-description, such
as <em>a resourceful person</em>; or 5) <em>someone,</em> which means
anyone except the player. The imperative rule body references what
matched with the variable <em>the actor</em>.</p>

<p>Next is the action. The action's full name is <em>inserting it
into</em> but only the part before the <em>it</em> goes here. So,
<em>inserting</em>. For the <em>before</em>, <em>instead</em>, and
<em>after</em> rulebooks our options also include <em>doing
something</em> which means any action, or a list of actions such as
<em>looking, examining, or taking</em>, or variations on <em>doing
something except looking, inserting, or examining</em>. For the
exception list, we can check the parameters as well, but the arity of
the check must be equal: <em>doing something except inserting or
examining someone</em> would be rejected. But <em>doing something except
inserting someone or examining someone</em> would be fine, as they both
check the same arity.</p>

<p>Next is the noun fed to the action, such as whatever is currently in
<em>my favorite toy</em>. We can use a set-description here as well. The
variable <em>the noun</em> holds what matched. Or, if the parameter is
of a non-object type, one of <em>the [type] understood</em> variables is
used, such as <em>the topic understood</em>, <em>the time
understood</em>, <em>the number understood</em>, etc.</p>

<p>For actions with two parameters, a preposition follows. While the
player doesn't always need to enter a preposition &ndash; consider GIVE BOB
THE TOY &ndash; the programmer does. Since the action is named <em>inserting
it into</em>, our preposition is <em>into</em>. (The <em>it</em> in the
action name is a placeholder.)</p>

<p>The second noun follows, but we could have stuck the colon here to
end the preamble. Instead, <em>the jeans,</em> or any variable or
set-description. <em>Something</em> is synonymous with <em>a thing</em>,
and is the usual catch-all. The variable <em>the second noun</em>, or
<em>the [type] understood</em>, holds what matched.</p>

<p>But wait, there's more. The word <em>when</em> means <em>if</em>, and
any valid condition can follow it. <em>The time of day</em> is a time
variable in the library, automatically advanced one minute per
understood player command. The "is before" means "is less than".</p>

<p>Finally, the colon marks the end of the rule preamble &ndash; the
regex-like part of the rule &ndash; and the start of the imperative code
block. (One piece of syntactic sugar: a comma can be substituted for the
colon if the imperative code block is a single line, and the rulebook
begins with <em>before, after, instead of, when</em>, or <em>every
turn</em>. Very pretty code can result.) Here our block consists of a
single print statement. The trailing "instead" is another bit of
syntactic sugar for appending the statement <em>rule fails</em>. Since
the rule failed, the rulebook also fails, and execution skips ahead to
the <em>every turn</em> phase of the turn. Since that skips the
<em>carry out</em> rules, the action does nothing except print our
denial message in the situation our preamble describes.</p>

<p>All rules in the language follow that pattern. As for rulebooks, they
are simpler. Every rule ends in one of the statements <em>rule
succeeds</em>, <em>rule fails</em>, or <em>make no decision</em>. If we
don't specifically use one of those three statements at the end of the
rule, the rulebook's default is automatically appended. <em>Rule
fails</em> and <em>rule succeeds</em> both end the rulebook as well &ndash;
whatever task was given to the rulebook has completed. <em>Make no
decision</em> tells the rulebook to try the next applicable rule, and is
the default for any rulebook that runs all its rules. <em>Make no
decision</em> is the default for <em>when play begins, before</em>,
<em>check</em>, <em>carry out</em>, <em>report</em>, <em>every
turn</em>, and almost every other standard rulebook. Of course,
<em>instead</em> defaults to <em>rule fails</em>. <em>After</em> and
each activity's <em>for</em> default to <em>rule succeeds</em>.</p>

<p>So, some examples with actions. Square brackets outside a text string
denote comments.</p>

<div class="codeblock">
<div class="codeline">Report going when the current manager is in the location:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "See ya later, [the current manager]." instead.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">[ <em>once</em>, <em>twice</em>, and <em>for the Nth time</em> can end a preamble ]</div>
<div class="codeline">Carry out examining the cell phone for the first time:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;now the player worries about Jesse; [ <em>worries about</em> would be a relation ]</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;now the cell phone is fingerprinty. [ <em>fingerprinty</em> a boolean property ]</div>
</div>

<p>Some examples with other, background events.</p>

<div class="codeblock">
<div class="codeline">When play begins, say "Once upon a time..."</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">After reading a command when the player's command includes "quickly/quietly/slowly", say "I cannot understand adverbs in commands." instead. [ slashes mean <em>or</em> ]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Before printing the name of Bob, say "Mr. "</div>
</div>

<p>Within a rulebook, rules are sorted according to the specificness of
the preamble. So, <em>instead of examining someone suspicious</em> will
always be tried before <em>instead of examining someone</em> no matter
their source code order. All the various restrictions must still be
satisfied of course. This just determines what rules are tried first,
and if multiple rules share the same specificness, they are considered
in source code order. Although this setup sounds frighteningly like
building atop shifting sands, empirically it has worked better than
anticipated. This is likely because rules belong to rulebooks, and only
one rulebook is operating at any one time, in much the same way that
only one function operates at one time: the caller is "on hold". And
unlike Prolog's sea of rules, one rulebook is small enough to remember
at once. But when in doubt, there is the Index.</p>

<p>Found in the IDE, the Index is the automatically-generated author's
documentation. The Index button is labeled vertically along the right
edges of both panes, and will be empty until the first successful
compilation. The various tabs of the Index list all the constructs in
the author's work as of the latest compile. It's possible to learn a lot
just by reading it. The Actions tab lists all the actions the game
knows, both built-in and author-written, and lists the player words that
trigger each. Clicking the magnifying glass icon next to an action name
will show a detail page listing all the rules that can apply to it. The
Contents tab lists all variables and tables. The Kinds tab not only
contains the object hierarchy including all instantiations, but also all
other types and under what generic types they fall. The Phrasebook tab
holds procedures, functions, and relations. The Rules tab holds only
rules that do not apply to actions or scenes. The Scenes tab holds
detail on scenes and scheduled events, while the World tab holds the
room map.</p>

<p>Now that we've covered rules and the index that would be new to many
programmers, we can speed up our tour. The only thing left to start
creating games is how to give the player synonyms for objects and
actions. Set-descriptions can be within the square brackets here, but
generally it's better to allow much at this parsing stage, and use
<em>check</em> rules to print better denial messages for attempts to
wear doorknobs or eat Ferraris.</p>

<div class="codeblock">
<div class="codeline"><strong>Understand</strong> "squint at [something]" <strong>as</strong> examining.</div>
<div class="codeline"><strong>Understand</strong> "dash [direction]" <strong>as</strong> going.</div>
<div class="codeline"><strong>Understand</strong> "stick [something carried by the player] down/into [something]" <strong>as</strong> inserting it into.</div>
<div class="codeline"><strong>Understand</strong> "Robert" or "Rob" <strong>as</strong> Bob.</div>
<div class="codeline"><strong>Understand</strong> "dude" <strong>as</strong> a man. [ narrows down the referent to objects of class Man ]</div>
</div>

<p>Conditions can be attached. <em>The item described</em> is the
<em>self</em> or <em>this</em> variable used in other languages. For
properties, a shortcut obeys the current state of the property.</p>

<div class="codeblock">
<div class="codeline"><strong>Understand</strong> "bastard" or "rat bastard" <strong>as</strong> Bob <strong>when</strong> the time of day is before the deadline.</div>
<div class="codeline"><strong>Understand</strong> "fingerprinty" <strong>as</strong> a thing <strong>when</strong> the item described is fingerprinty.</div>
<div class="codeline"><strong>Understand</strong> the fingerprinty <strong>property as describing</strong> a thing. [ better for properties ]</div>
<div class="codeline"><strong>Understand</strong> "smudged" <strong>as</strong> fingerprinty.</div>
</div>

<p>Functions are called to-decide phrases. Because their return values
cannot be thrown away, they will always appear within a larger
statement, and so, are named after noun phrases.</p>

<p>Below, <strong>bold type</strong> shows keywords in the definition
before the colon. The colon is where the function body starts.
<em>Decide on</em> is the return statement. The return value comes just
before <em>is</em>. Slashes denote a choice of word (pick exactly one),
or when combined with the -- double- dash, the word is optional. Python
indentation, or <em>begin</em> and <em>end if/repeat/while</em>, denote
blocks, but begin-end and Python indentation cannot be mixed with each
other in the same function.</p>

<div class="codeblock">
<div class="codeline"><strong>To decide which</strong> number <strong>is</strong> (x - a number) smooshed with (y - number): decide on x multiplied by y.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>To decide what</strong> object <strong>is</strong> my toy:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;if the Ferarri is in the location, decide on the Ferarri; otherwise decide on nothing.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>To decide which</strong> person <strong>is</strong> who wears the pants around/in the/-- house of (p - an unhappy person):</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;if p is: [Python style is required to use the switch statement]</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- Bob: decide on Edith;</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- Jose: decide on Maria;</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- otherwise: decide on the mother of p.</div>
</div>

<p>Boolean (<em>truth state)</em> functions use <em>to decide if</em>
and are named after clauses. <em>Yes</em> and <em>no</em> are the phrase
versions of values <em>true</em> and <em>false</em>, while <em>whether
or not</em> typecasts between.</p>

<div class="codeblock">
<div class="codeline"><strong>To decide if</strong> (p - a person) will be done by (deadline - a time):</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;if p is Bob, yes;</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;otherwise decide on whether or not the time of day plus five hours is before the deadline.</div>
</div>

<p>Adjectives can be used as part of set-descriptions, which the above
cannot. The pronoun <em>it</em> refers to the object in question here,
but an explicit <em>called</em> parenthetical can name it. One-liners
can use <em>if</em> rather than the colon. The antonym is defined by
<strong>rather than</strong> but is optional.</p>

<div class="codeblock">
<div class="codeline"><strong>Definition:</strong> a person <strong>is</strong> overloaded <strong>rather than</strong> good <strong>if</strong> the number of workorders expected of it is at least five.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>Definition:</strong> a person (called the workerbee) <strong>is</strong> efficient <strong>rather than</strong> slow:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;<strong>repeat with</strong> item <strong>running through</strong> every workorder expected of the workerbee:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if the completion time of the item is greater than one hour, decide no;</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;decide yes.</div>
</div>

<p>On the downside, parameters cannot sit right next to one another. A
word must come between. But, the type of a parameter isn't just a type
or class, but anything from a specific value to a full-on
set-description. As with rules, Inform chooses the most specific
applicable phrase, and in the case of a phrase calling itself, prefers
not to recurse if possible. (This is mainly a safety feature for the lay
target audience.) So for the following procedures &ndash; functions which
return no value, and sometimes called to-phrases in Inform because
<em>to</em> is the only keyword they have in common &ndash; if Jenny doesn't
love the player, then invoking her name causes execution to ping-pong
between both applicable phrases.</p>

<div class="codeblock">
<div class="codeline"><strong>To</strong> tell (lover - a person) I love him/her/them recursively: say "I love you, [lover].";</div>
<div class="codeline">tell the lover I love them recursively.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>To</strong> tell (lover - a person which does not love the player) I love him/her/them recursively:</div>
<div class="codeline">say "I secretly love you, [lover]."; tell the lover I love them recursively.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>To</strong> tell (lover - Bob) I love him/her/them recursively:</div>
<div class="codeline">say "Er, how's [abrupt subject change] coming along?"</div>
</div>

<p>Say-phrases are called from within text strings. <em>If</em>
constructions are standard, but cannot nest: "[if Jenny loves Bob]What?
Why?[otherwise if Bob loves Jenny]Welcome to the club. [otherwise]Won't
she give me her number?[end if]"</p>

<div class="codeblock">
<div class="codeline"><strong>To say</strong> abrupt subject change:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;if the current weather conditions are not mostly sunny:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;say "the weather";</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;otherwise if Edith is not in the location:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;say "you and Edith";</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;otherwise:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;say "the Chicago Cubs".</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>To say</strong> looks like it's (w - a weather condition):</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;if w is nasty, say "blowing up a storm";</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;otherwise say w.</div>
</div>

<p>A blank line, or a period substituted for a semicolon, ends a
phrase.</p>

<p>Named values (known as enums in C) can do most anything objects can
do, and needn't be all defined at once. <em>A weather condition is a
kind of value. Some weather conditions are rainy, partly cloudy, mostly
sunny, about to snow, and nasty. A weather condition is a tornado
warning. A metal is a kind of value. The metals are copper, tin, iron,
aluminum, platinum, nickel, gold, and silver.</em> One standard kind of
value receives special attention: scenes. With a <em>during</em>
preamble phrase and its own SCENES testing command, scenes are a
powerful organizing principal in an interactive fiction.</p>

<div class="codeblock">
<div class="codeline">The denouncement is a scene.</div>
<div class="codeline">The denouncement begins when the climax ends.</div>
<div class="codeline">Instead of taking something during the denouncement, say "But the life of a kleptomaniac seems so empty now."</div>
</div>

<p>Boolean properties. <em>A person can be happy or unhappy. A person
can be resourceful. A person is usually not resourceful. A weather
condition can be later in the evening. A weather condition is usually
not later in the evening.</em></p>

<p>Valued properties. <em>A person has a person called its mother. A
weather condition has a time called the predicted duration. The
predicted duration of a weather condition is usually five hours. Bob's
mother is Agnes.</em></p>

<p>Subclassing. <em>A boy is a kind of man. A girl is a kind of
woman.</em> Statically-allocated means no constructors or destructors.
Inform can insert new classes between existing classes. <em>A conveyance
is a kind of container. A vehicle is a kind of conveyance.</em> This
does not contradict the standard <em>a vehicle is a kind of
container.</em></p>

<p>Timed events are rules that self-invoke at a given time or in a given
number of turns. They fire only once, but named ones can re-schedule
themselves.</p>

<div class="codeblock">
<div class="codeline"><strong>At</strong> 6:30 am: <strong>say</strong> "Your alarm clock screams you awake."</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>At the time when</strong> an email arrives:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;<strong>say</strong> "You've got mail."; an email arrives <strong>in</strong> seven <strong>turns from now</strong>.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>At the time when</strong> the alarm clock screams:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;<strong>say</strong> "Your alarm clock screams you awake."; the alarm clock screams <strong>at</strong> 6:30 am.</div>
</div>

<p>Activities are multi-rulebook events not generated by the player.
They exist merely so the library (or authored extensions) may provide
hooks for important events. The three phases of an activity are
<em>before, for,</em> and <em>after. Printing the name, supplying a
missing noun, printing a parser error,</em> and <em>reading a
command</em> are the most useful. Other standard rulebooks which are not
full-on activities are <em>does the player mean</em>,
<em>persuasion</em>, and <em>unsuccessful attempt by</em>.</p>

<div class="codeblock">
<div class="codeline"><strong>After printing the name</strong> of Bob: say " Jr."</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>After reading a command</strong> when the player's command includes "please/thanks", cut the matched text.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>After reading a command</strong> when the player's command matches "take nap", replace the matched text with "sleep".</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>For printing a parser error</strong> when the latest parser error is I beg your pardon: say "Please type something in."</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>Does the player mean</strong> taking the train: it is very unlikely. [getting on or entering the train, perhaps]</div>
</div>

<p>Arrays currently have little support since who would want to read
about a hundred perfectly identical things? Still, it's possible to
instantiate numerous unnamed objects, but only if we specifically create
a subclass for it. <em>A coin is a kind of thing. Seven coins are in the
sofa. A light is a kind of thing. There are four lights.</em> While the
player can TAKE THREE COINS, the programmer resorts to set-descriptions
and <em>a random</em>, such as <em>a random off-stage coin.</em> (<em>A
random</em> is a decide phrase, not an adjective. The <em>a</em> is
required. <em>Off-stage</em> is when <em>location</em> is
<em>nothing</em>.) Tables are 2D arrays, mostly, and can instantiate a
slew of objects or named values at once. Tabs are required between
columns. A -- double-dash is a blank entry.</p>

<div class="codeblock">
<div class="codeline">A workorder is a kind of value.</div>
<div class="codeline">Some workorders are defined by the table of tasks.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Table of tasks</div>
<table>
<tbody>
<tr>
<td style="text-align: left;">workorder</td>
<td style="text-align: left;">employee</td>
</tr>
<tr class="odd">
<td style="text-align: left;">send invoices</td>
<td style="text-align: left;">Bob</td>
</tr>
<tr class="even">
<td style="text-align: left;">check addresses</td>
<td style="text-align: left;">--</td>
</tr>
<tr class="odd">
<td style="text-align: left;">restock</td>
<td style="text-align: left;">Bob</td>
</tr>
</tbody>
</table>
</div>

<p>And we close off the firehose with relations. Object-oriented
programming is built on two object-to-object relations, is-a and has-a.
Single inheritance is one-to-various, while multiple-inheritance is
various-to-various. Object properties in general are each a
various-to-one relation. Indeed, that's frequently how Inform implements
them: the <em>called</em> parenthetical allows the <em>noun of noun</em>
syntax of properties as an alternative to the <em>noun verb noun</em>
syntax of relations. But <em>called</em> is restricted to the singular,
so the <em>reversed</em> word may be needed.</p>

<p>Finally, Inform already knows the singular (-s), plural (root), past
(-ed), past participle (-en), and present participle (-ing) forms of
<em>be</em>, so the large parenthetical is omitted for such.</p>

<div class="codeblock">
<div class="codeline">Single inheritance <strong>relates</strong> one thing <strong>(called</strong> the parent<strong>)</strong> <strong>to</strong> various things.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>The verb to</strong> be the superclass of <strong>implies</strong> the single inheritance relation.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>The verb to</strong> inherit from <strong>(he</strong> inherits from, <strong>they</strong> inherit from, <strong>he</strong> inherited from, <strong>it</strong> is inherited, <strong>he</strong> is inheriting from) <strong>implies</strong> the <strong>reversed</strong> single inheritance relation.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>now</strong> dog <strong>inherits from</strong> animal; [ These are synonymous, but note we're not using Inform's actual class hierarchy. ]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>now</strong> the <strong>parent</strong> of dog <strong>is</strong> animal; [ The real class hierarchy is immutable at runtime. ]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>now</strong> animal <strong>is the superclass of</strong> dog;</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Assignment <strong>relates</strong> various workorders <strong>to</strong> one person <strong>(called</strong> the employee<strong>)</strong>.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>The verb to</strong> be expected of <strong>implies</strong> the assignment relation.</div>
</div>

<h2 id="class-and-prejudice">Class and Prejudice</h2>
<p>Here's the built-in class hierarchy, a total of sixteen classes.
(Also, where other languages say "class", Inform says "kind".) Inform
purposely keeps its library lean.</p>

<p>
  object<br>
  <ul class="bullet">
    <li>direction</li>
    <li>room</li>
    <li>region</li>
    <li>thing
      <ul class="bullet">
        <li>door</li>
        <li>container
          <ul class="bullet">
            <li>vehicle</li>
            <li>player's holdall</li>
          </ul>
        </li>
        <li>supporter</li>
        <li>backdrop</li>
        <li>device</li>
        <li>person
          <ul class="bullet">
            <li>man</li>
            <li>woman</li>
            <li>animal</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</p>

<p>A quick rundown: Room is a discrete location, a place; Region is a
container for Rooms. The class Container means an in-game prop, such as
a backpack or hamster cage. A Supporter is a chair, table, mantel, or
other horizontal surface Bob can place things on top of. The player's
holdall is usually a singleton, as it's a container without load limits.
A instance of Door can explicitly connect Rooms, and can be open &amp;
closed if not also locked &amp; unlocked. Direction does NOT connect
rooms &ndash; relations do that &ndash; but is used in code to reference the
same.</p>

<p>Backdrop always has the boolean property <em>scenery</em> set, and is
used for things like the sun in the sky, the faint but ever-present
sound of a nearby creek, and other non-portable objects that need to
remain in the parser's scope while the protagonist travels across
several Rooms.</p>

<p>Device is something that can be switched on/off. Animal is treated as
a kind of person, just as pets are.</p>

<p>The positioning of Animal is our first hint that we're stepping out
of a scientific worldview, and into a humanistic one. Likewise, the
purpose of the language as a whole is to produce works of art, not
software tools.</p>

<p>Making a subclass is straightforward. Note that <em>are</em> can
replace <em>is</em>, and most any article can replace <em>a</em>.</p>

<div class="codeblock">
<div class="codeline">An archway <strong>is a kind of</strong> <em>door</em>.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">An archway <strong>has</strong> <em>a number</em> <strong>called</strong> the horizontal clearance. It <strong>is usually</strong> 6.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">An archway <strong>is always</strong> <em>open</em>.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">An archway <strong>can be</strong> magic <strong>or</strong> mundane. An archway <strong>is usually</strong> not magic.</div>
</div>

<p>This subclasses archway from door. It gives it a new numeric property
call the <em>horizontal clearance</em> with an initial value that can be
overridden by a particular instance. Then it permanently sets the
pre-existing open/closed property to <em>open</em> so attempts to later
code a closed archway will result in a compiler error. Finally, it gives
it a new anonymous boolean property with named values <em>magic</em> and
<em>mundane</em> (as opposed to a property called "magic" with values
"true" and "false"). It initializes this to <em>mundane</em>. We could
have just said <em>an archway can be magic</em> and it would still work,
but naming the antonym usually improves readability.</p>

<p>One instance of <em>person</em> is always provided for us:
<em>yourself</em>. <em>The player</em> is a person variable initialized
to <em>yourself</em> unless defined otherwise. (Only the player refers
to the avatar as ME.) One instance of Object (the root-level class) is
always provided: <em>nothing,</em> the nil pointer.</p>

<p>Occasionally synonyms nowhere, nobody, no-one, and no one may be
used, but it's usually a special-case syntax.</p>

<div class="codeblock">
<div class="codeline"><strong>The player</strong> is Bob. [ the <em>yourself</em> object still exists, though unused ]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">[...];</div>
<div class="codeline">now <strong>the player</strong> is Bob; [ imperatively, at runtime ]</div>
</div>

<p>Object names can unfortunately occlude one another. If we have an
object "car", and then an object "car key", it frequently happens that
the parser cannot refer to the car. Inform supplies objects with a
property, <em>privately-named</em>, which prevents automatically
exporting an object's source code name to the player's parser. Instead,
an explicit <em>understand</em> line will be required.</p>

<p>The articles <em>a, an,</em> and <em>the</em>, and including
<em>some</em> when used similarly, are only mostly ignored in Inform.
Inform will mimic in the game's output the articles used in the source,
with the object's first mention in the source given extra weight in case
of inconsistent usage. Objects created with <em>some</em> will be
treated as mass nouns, and objects whose names are always capitalized in
the source are capitalized as proper names.</p>

<p>Inform does not (currently) support arrays, but it does have a couple
of alternatives. A later section shows us tables, which are similar to
2D arrays. But here, we can instantiate up to a hundred
indistinguishable instances of a kind at once. A subclass is required
for this, but that is easy enough to arrange.</p>

<div class="codeblock">
<div class="codeline">A coin is a kind of thing.</div>
<div class="codeline">55 coins are in the couch.</div>
<div class="codeline">Three coins are carried by the player.</div>
<div class="codeline">There are seven [more] coins.</div>
</div>

<p>That last definition creates objects but leaves them
<em>off-stage</em>. The commented-out word "more" is only placed there
for clarification. It is especially useful in cases like: <em>There are
seven coins. Three coins are in the couch</em>. Those sentences might
imply there are a total of seven coins in the world, rather than ten,
seven being <em>off-stage</em> and three <em>on-stage</em>.</p>

<p>There's a few things to know about unnamed instances. We must
subclass before instantiating or else we'll have a single object called
"55 coins". We can't reference "the thirty-second coin" like we could
with an array, but instead must use set-descriptions with <em>a
random</em> to grab one: <em>try taking a random tarnished coin which is
not carried by the player</em>. And it's up to us to verify such an
instance exists. We can't specify a quantity of them as in <em>now the
player carries three coins</em> or <em>try taking three coins</em>
because Inform won't know which three coins, but we can manipulate all
of them as in <em>now the player carries every coin</em>. So,
instantiate away, but as far as Inform 7 is concerned, there's only
zero, one, or infinite coins.</p>

<p>Our player can TAKE THREE COINS if the action's <em>understand</em>
line applies to <em>[things],</em> plural, as <em>taking</em> and
<em>dropping</em> already do. Furthermore, we can expose the various
properties (adjectives) of our new subclass to the player's parser,
giving the player the ability to differentiate with TAKE THREE TARNISHED
COPPERS. <em>As referring to</em> exposes it as a pure adjective, while
<em>as describing</em> exposes it as both adjective and noun.</p>

<div class="codeblock">
<div class="codeline">A coin can be pristine or tarnished.</div>
<div class="codeline">A metal is a kind of value.</div>
<div class="codeline">The metals are copper, silver, and gold.</div>
<div class="codeline">A coin has a metal.</div>
<div class="codeline">Understand "coppers" as copper.</div>
<div class="codeline">Understand "silvers" as silver.</div>
<div class="codeline">Understand "golds" as gold.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>Understand</strong> the tarnished <strong>property as referring to</strong> a coin. [ <em>tarnished</em> or <em>pristine</em> by itself won't grab a coin ]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>Understand</strong> the metal <strong>property as describing</strong> a coin. [ but <em>copper, silver,</em> or <em>gold</em> will ]</div>
</div>

<p>Though we wouldn't normally expect the player's parser to be more
expressive than the programmer's, in the case of taking three coins, the
runtime always has the option of interactively asking for details
("Which did you mean?") while we do not.</p>

<h2 id="the-coding-imperative">The Coding Imperative</h2>
<p>Here are examples of all the basic imperatives. Read the print
statements within.</p>

<div class="codeblock">
<div class="codeline">let Z be 5; [ Local variable declaration; Type is usually inferred. ] </div>
<div class="codeline">let t be indexed text; [ Explicitly stating type, for next line. ]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">let t be "Hello world"; [ This will be <em>indexed text</em> instead of <em>text</em>. ] </div>
<div class="codeline">now X is 5; [ assignment ]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">now every V W is X Y Z; [ assign properties X, Y, and Z to all instances of W which already possess V. ]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">if X > Y, say "A comma is synonymous for 'then'.";</div>
<div class="codeline">otherwise say "'Otherwise' (or 'else') must be a one-liner if the 'if' was a one-liner. No punctuation follows the word.";</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">if X > Y begin;</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "'Begin' requires a semicolon of its own."; </div>
<div class="codeline">otherwise;</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "As does the matching 'otherwise' and 'end'.";</div>
<div class="codeline">end if;</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">if X > Y:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "Python-esque style is OK as long as we don't mix the two styles in the same function.";</div>
<div class="codeline">otherwise:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "Posting code to internet forums usually corrupts the tabs, but tables require tabs anyway.";</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">if X is greater than Y begin;</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "This is a else-if chain. Also, notice that relational operators can be spelled out.";</div>
<div class="codeline">otherwise if X is Y;</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "Only a semicolon is found for the trailing conditionals."; </div>
<div class="codeline">otherwise;</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "The final otherwise is the same as usual.";</div>
<div class="codeline">end if;</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">if X is greater than Y:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "This is a else-if chain in Python style."; </div>
<div class="codeline">otherwise if X = Y:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "The punctuation here is more regular: always a colon, no matter what.";</div>
<div class="codeline">otherwise:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "The = is rarely seen by itself, in practice; 'is' is easier to type.";</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">unless X <= Y, say "'Unless' means 'if not'. Also, inequalities are written >= or <=, never => or =<.";</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">if X is:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;-- 1: say "A switch statement masquerades as an if statement. 'Unless' cannot be used.";</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;-- 2: say "Python style only.";</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;-- otherwise: say "There is no fall-through between cases, and no goto to restore it.";</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">if my favorite toy is:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;-- the red Ferrari: say "Numbers and objects both can be used in switches.";</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;-- the jeans: say "Also note the further indentation of the cases, and their subsequent lines.";</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">repeat with X running from 1 to 10:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "'Repeat' is the usual loop construct. It has [X] forms. This enumerated one isn't used much.";</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">repeat with clothing running through every wearable thing:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "The 'description' type describes a set of objects.";</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">if the clothing is the pair of shoes, say "Also, 'every', 'each', or 'all' aren't required here but may read better.";</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">repeat with target running through all limbs:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;if the target is the head, say "We can repeat through named values, scenes, action names, etc. just as easily.";</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">repeat with programmer running through the men who are in a lighted room (called the mainframe's area):</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "[The programmer] in [the mainframe's area] says we can do some pretty complex stuff with 'descriptions'.";</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">next; [ 'next' starts the loop over at the next iteration. C calls this 'continue' ]</div>
<div class="codeline">break; [ 'break' kills the loop immediately ]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">repeat through the table of designs:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "Tables are 2D arrays. We'll look at them in detail in their own section.";</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">while X is at least Y begin;</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "While loops are rarely seen in practice.";</div>
<div class="codeline">end while;</div>
</div>

<p>Semicolons divide statements as usual, but the last semicolon should
instead be a period. Alternately, the last statement should be followed
by a blank line. This is how the end of a function is signified.</p>

<p>Inform calls the above imperatives, and other things like them,
<em>phrases</em>. Functions are also called phrases, because they are
invoked similarly. But rules are different; they invoke themselves based
on game events and other worldsim situations. Here's some quick examples
just so we'll have somewhere to try out our imperative code.</p>

<div class="codeblock">
<div class="codeline">When play begins: say "Hello world!".</div>
<div class="codeline">Every turn: say "La-dee-da."</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Instead of taking yourself, say "You pull yourself up by your bootstraps and read on." </div>
</div>

<p>Remember to instantiate a room.</p>

<h2 id="boolean-adjectives">Boolean Adjectives</h2>
<p>Adjectives, and the set-description type that invokes them, are
Inform's big win over the COBOL and HyperTalk families of natural
language programming languages. Typically used for objects, a
description uses combinations of adjectives and/or relations with a
class to define a set of instantiations. This is responsible for a great
deal of Inform's conciseness over traditional programming languages.
First we'll look at how to define the adjectives.</p>

<p>There are a few ways to define a boolean adjective. The first creates
an anonymous boolean property with named values.</p>

<div class="codeblock">
<div class="codeline">A thing <strong>can be</strong> spiffy.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">A person <strong>can be</strong> grumpy <strong>or</strong> happy.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>now</strong> the iPod <strong>is</strong> not spiffy;</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>if</strong> Mary <strong>is</strong> happy, <strong>now</strong> Bob <strong>is</strong> grumpy;</div>
</div>

<p>Inform of course understands <em>not spiffy</em> but it also
understands <em>not grumpy</em> as synonymous with <em>happy</em> and
vice-versa. Also, since <em>person</em> is subclassed from
<em>thing</em>, a person can also be spiffy. Frequently in OOPLs, new
properties and methods cannot be added to a pre-existing class because
doing so would break pre-existing code that uses it. Subclassing is
required to add such embellishments. But since Inform isn't designed for
reusable code or team coding, it allows directly modifying classes, and
those changes propagate down the hierarchy regardless whether they are
built-in or not. The allowed modifications are additive only, however.
(Though sectional replacement of source code alleviates even that.)</p>

<p>The second way to define an adjective works like adding a
boolean-returning method to a class. It also has a one-liner version
using <em>if</em> instead of a second colon:</p>

<div class="codeblock">
<div class="codeline"><strong>Definition:</strong> a person <strong>is</strong> kinda dull<strong>:</strong> [...]; decide no.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>Definition:</strong> a person <strong>is</strong> unlikable <strong>if</strong> it is kinda dull or it is grumpy.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>Definition:</strong> a person <strong>(called</strong> the academic<strong>) is</strong> laconic <strong>rather than</strong> chatty <strong>if</strong> the academic is [...].</div>
</div>

<p>The pronoun <em>it</em> refers to the object on which the method is
called, where traditional languages use "self" or "this" or some such.
This can be customized with the <em>called</em> parenthetical. An
antonym may be defined with the <em>rather than</em> phrase.
<em>Definition:</em> adjectives aren't restricted to objects. Named
values are also common here.</p>

<p>(The third way, using a plain <em>to decide if</em> boolean function,
loses the flexibility of appearing in set-descriptions. But, being a
function, it can take any number of arguments, and may use the powerful
parameter-matching logic of same. We will see them soon.)</p>

<p>The adjectives are checked the same way regardless whether they are
data or calculated, so changing an adjective from a variable
implementation to a calculated implementation (or vice-versa) only
requires adding or removing any lines that explicitly set the
adjective's value. Client code that merely checks the value needn't
change.</p>

<div class="codeblock">
<div class="codeline"><strong>repeat with</strong> associate <strong>running through</strong> every chatty not grumpy spiffy person: say "Hi [associate]."</div>
</div>

<h2 id="patterned-procedures">Patterned Procedures</h2>
<p>A procedure's "name" in Inform 7 is not an exact match of a single
identifier, but a simple textual pattern. The word <em>to</em> starts
the definition, and parenthesis enclose the local variable name, a
hyphen, and the type. A colon ends the "name" and the imperative code
block begins.</p>

<div class="codeblock">
<div class="codeline"><strong>To</strong> plainly greet (friend - a person): say "Hi [friend]."</div>
</div>

<p>The above is invoked readably.</p>

<div class="codeblock">
<div class="codeline">plainly greet Dr. Muller;</div>
</div>

<p>The / forward slash can be used to allow synonyms for a word by
acting as a high-precedence disjunction: choose exactly one. Its effect
ends at the first space. The -- double-dash in a disjunction means the
word is optional: choose at most one.</p>

<div class="codeblock">
<div class="codeline"><strong>To</strong> ponder/mull over/-- (good point - a thing) for (awhile - a time) as (ponderer - a person):</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "[Ponderer] sits back for about [awhile]. 'Hm, [good point] is a very good point.'"</div>
</div>

<p>The following invocations are all equivalent.</p>

<div class="codeblock">
<div class="codeline">ponder the best idea yet for 7 minutes as Dr. Muller;</div>
<div class="codeline">ponder over the best idea yet for 7 minutes as Dr. Muller; </div>
<div class="codeline">mull best idea yet for 7 minutes as Muller;</div>
<div class="codeline">mull over the best idea yet for 7 minutes as Dr. Muller;</div>
</div>

<p>A parameter can immediately follow the <em>to</em> that begins the
definition, but parameters cannot sit immediately side-by-side.</p>

<div class="codeblock">
<div class="codeline"><strong>To</strong> (ponderer - a person) ponders (good point - a thing)<strong>:</strong> [ok]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>To</strong> ponder for (awhile - a time) (good point - a thing)<strong>:</strong> [error!]</div>
</div>

<p>The types of the parameters needn't be a single type, or even a type
at all. Set-descriptions and particular values both may narrow the scope
of the input. Like actual rules, this is a handy feature for special
cases.</p>

<div class="codeblock">
<div class="codeline"><strong>To</strong> plainly greet (foo - people which are friends with the player): [...]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>To</strong> plainly greet (foo - a resourceful person): [...]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>To</strong> plainly greet (foo - nothing): say "Run-time error: called 'plainly greet' with nothing."</div>
</div>

<p>While set-descriptions narrow the accepted range of input, generic
types allow one phrase to cover many different types. The type of a
parameter itself can be captured and used elsewhere in the definition
and/or code block via the phrase <em>value of kind K</em> and similar
variables <em>L, M,</em> etc. <em>Sayable value</em>, <em>word
value</em>, <em>pointer value</em>, <em>arithmetic value, enumerated
value</em>, and the most generic of them all, <em>value</em>, are the
known generic types. They can be used with or without <em>of kind
K</em>.</p>

<div class="codeblock">
<div class="codeline"><strong>To</strong> debug-print the differences between (construct one - a sayable value of kind K) and (construct two - K): [...]</div>
</div>

<p><em>Let</em> creates a local variable. <em>Let</em> is also how we
create flexibly-sized types like <em>list</em> and <em>indexed
text</em>, since they cannot be statically allocated and the language
does not allow dynamic allocation.</p>

<div class="codeblock">
<div class="codeline"><strong>let</strong> X <strong>be</strong> 5;</div>
<div class="codeline"><strong>let</strong> the typical exclamation <strong>be</strong> "That's cool!";</div>
<div class="codeline"><strong>let</strong> the articles of clothing <strong>be</strong> the list of things worn by Bob;</div>
<div class="codeline"><strong>let</strong> M <strong>be</strong> { the red Ferrari, the pair of shoes };</div>
<div class="codeline"><strong>let</strong> the modifiable exclamation <strong>be</strong> indexed text; [ These work... ]</div>
<div class="codeline"><strong>let</strong> the modifiable exclamation <strong>be</strong> "That's cool!"; [ ...as a pair. ]</div>
</div>

<p><em>Stop</em> is the plain-jane return statement. It isn't used much,
partly because of some other synonyms for return, and partly as fallout
from the rules-based structure of the language.</p>

<p>A final natural-language feature cloaks a bitfield as a series of
comma-separated sub-phrases.</p>

<div class="codeblock">
<div class="codeline"><strong>To</strong> go hiking, into the woods or up the mountain:</div>
<div class="codeline">if into the woods then say "Watch out for badgers.";</div>
<div class="codeline">if up the mountain then say "Better take your compass.";</div>
<div class="codeline">say "You go hiking."</div>
</div>

<p>Clever naming not only affords client code that is easy to read, but
also creates library invocations that are easy to make a half-remembered
guess at. The latter is, in practice, a wonderful time-saver. When we
define functions, we should take client code readability into account.
For example, we needn't add the articles in front of a parameter,
because the parameter itself will eat it.</p>

<div class="codeblock">
<div class="codeline"><strong>To</strong> ponder the/an/a/-- (nefarious plans - a rulebook): [ unnecessary ]</div>
<div class="codeline"><strong>To</strong> ponder (nefarious plans - a rulebook): [ better ]</div>
</div>

<p>But we should explicitly add the articles if it occurs elsewhere,
such as this example that pretends to understand an adjective in some
cases.</p>

<div class="codeblock">
<div class="codeline"><strong>To</strong> ponder the/an/a/-- foiled/new/-- (nefarious plans - a rulebook): [ necessary ]</div>
</div>

<p><strong>To</strong> phrases tend not to be used too much, for the
similar reason that methods in a OO language tend to reduce global
function use. Instead, Inform 7 has rules, grouped into rulebooks, which
we'll get to shortly. To-phrases do have a nicer invocation syntax and
essentially unlimited arity to recommend them over rules, but they lack
some of the flexibility of rulebooks, as we will soon see.</p>

<h2 id="functions-decide-on-a-value">Functions Decide on a Value</h2>
<p>Because strong-typing requires returned values to be used, functions
will always be used in a larger statement. Hence their names tend to be
noun phrases rather than sentences.</p>

<div class="codeblock">
<div class="codeline"><strong>To decide which</strong> room <strong>is</strong> my favorite place: [...]; <strong>decide on</strong> My Bedroom.</div>
<div class="codeline"><strong>To decide what</strong> person <strong>is</strong> the brother to/of (sibling - a person): [...]; <strong>decide</strong> sibling.</div>
<div class="codeline"><strong>To decide which</strong> object <strong>is</strong> my fabulous doodad: <strong>decide on</strong> a random thing.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">ponder the best idea in <strong>my favorite place<em>;</strong></em></div>
<div class="codeline">if <strong>the brother to <em>the noun</strong></em> is not the noun, say "[The noun] has a brother, [<strong>the brother of <em>the noun</strong></em>].";</div>
<div class="codeline">if <strong>my fabulous doodad</strong> is nothing, say "I'm fresh out of fabulous.";</div>
</div>

<p><em>To decide which</em>, or synonymously, <em>to decide what</em>,
begin the definition. The return value follows, and then <em>is</em>.
The function's name is only that part between <em>is</em> and the colon.
The return statement is <em>decide on</em>. Due to strong-typing and
<em>nothing</em> being pronounced an instantiation of class
<em>object</em>, we cannot <em>decide on nothing</em> except when the
function's return value is type object.</p>

<p>Boolean functions must use the slightly different <em>whether/if</em>
variation, and the name lies between the <em>whether</em> or <em>if</em>
and the colon. Since they are invoked from if statements and rule
headers, their names are usually clauses sans subordinating
conjunction.</p>

<div class="codeblock">
<div class="codeline"><strong>To decide whether</strong> (pants - a thing) is/are on fire:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;<strong>decide on</strong> whether or not a random chance of 1 in 2 succeeds.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">if <strong><em>the brother of the noun</em> is on fire</strong>, say "That's gonna leave a mark."</div>
</div>

<p>The phrase <em>whether or not</em> typecasts an if-condition (such as
if "a random chance of M in N succeeds") to a truth state (boolean),
which can then be returned.</p>

<h2 id="say-phrases">Say Phrases</h2>
<p>It is so common to slightly vary some prose for a given situation
that Inform specifically provides for procedures called from within a
<em>say</em> statement's prose. Say-phrases are in a box separate from
to-phrase procedures and to-decide functions, but otherwise work
identically. They are invoked by square brackets within a text
string.</p>

<p>Gendered pronouns are a common case, and most are built-in.</p>

<div class="codeblock">
<div class="codeline"><strong>To say</strong> He-She for (P - a person):</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;if P is plural:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;say "They";</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;otherwise:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if P is female, say "She";</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;otherwise say "He";</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>To say</strong> (P - a person) mulls/ponders --/over (idea - a thing):</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;[...];</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "[He-She for Chris] glances at you[Chris ponders tar-and-feathering].";</div>
</div>

<p>Putting a bare object or variable name within the square brackets
prints the entity's name or variable's value, respectively. This works
for nearly every type in the language, though can usually be overridden
like so.</p>

<div class="codeblock">
<div class="codeline"><strong>To say</strong> (code - a rule): abide by the code.</div>
</div>

<p>That would execute the rule or rulebook from within prose, rather
than printing something.</p>

<div class="codeblock">
<div class="codeline">say "Chris seems to make a decision.[the formulate plans rules] But you don't know what.";</div>
</div>

<p>Inform ships with a number of basic imperatives for say phrases. The
docs have the full list, and the Extensions chapter has information on
creating new multi-part To Say constructions.</p>

<div class="codeblock">
<div class="codeline">say "He put on [if the jeans are stained]yesterday's[otherwise]his[end if] jeans.";</div>
<div class="codeline">say "The weather was [one of]rainy[or]sunny[or]windy[at random].";</div>
</div>

<h2 id="types-of-types">Types of Types</h2>
<p>We know defining a class that implements a list of numbers is
tedious, but not as tedious as doing it again for strings, objects, and
any other type the language supports. Most languages nowadays provide
for this problem, such as the templates of C++. Inform too offers
generic types. <em>Arithmetic value</em> allows numbers and units.
<em>Pointer value</em> includes indexed text, stored actions, and other
variable-sized chunks of memory. <em>Word value</em> covers all
non-pointer values, including objects. <em>Sayable value</em> is any
type allowed in a print statement, which is almost anything.
<em>Enumerated value</em> is named values, which includes scenes. And
finally, <em>value</em> is all of them: just about anything that can be
passed as a parameter. The Kinds Index in the IDE shows what types
belong under which umbrellas. We can use them to define a phrase like
this.</p>

<div class="codeblock">
<div class="codeline">To place angle brackets around (foobar - <strong>a sayable value</strong>):</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "<<[foobar]>>".</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">To print the elements of (stuff - <strong><em>a list of</em> sayable values</strong>):</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "The list contains [stuff]."</div>
</div>

<p>Kind variables tie two or more parameters to the same type. This is
particularly useful when one parameter is an aggregate type, and the
other is the type being put into, brought out of, or compared to an
element of, that aggregate. Kind variables are always a single
capitalized letter, and traditionally use K and L.</p>

<div class="codeblock">
<div class="codeline">To decide which <strong>K</strong> is the initial contents of (stuff - <strong><em>a list of</em> arithmetic values of kind K</strong>): [...]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">To we will ask if (col - a <strong>K</strong> valued table column) is (data - <strong>a word value of kind K</strong>): [...]</div>
</div>

<p>The words <em>value of kind</em> must precede exactly one of the Ks.
That parameter will be the one that declares what K holds, so the other
parameter's input will be expected to match. For example, the following
line means the second parameter decides what K is, so the compiler will
search for a table column of that type.</p>

<div class="codeblock">
<div class="codeline">To we will ask if (col - a <strong>K</strong> valued table column) is (data - <strong>a value of kind K</strong>): [...]</div>
</div>

<p>While this means the first parameter's type sets K, and the second
will be interpreted as the type in question.</p>

<div class="codeblock">
<div class="codeline">To we will ask if (col - <strong>a value of kind K</strong> valued table column) is (data - <strong>K</strong>): [...]</div>
</div>

<p>It makes a difference. A very few types are implicitly casted between
each other, such as text and indexed text, and whether K is text or
indexed text will likely matter in the body of the function. Other
times, the compiler may have a choice of constructs with the same name
but different types. Or, the same words of source text may have
radically different interpretations depending on what type the compiler
expects it to yield. And one final note: the return value cannot set the
kind variable. It may use one, as the above example with initial
contents, but cannot declare it.</p>

<p>The parameter <em>name of kind of value</em> is an interesting case
because, rather than accepting a particular instantiation of a
restricting type, it asks for the source code's name of a type, such as
<em>object</em> or <em>room</em> or <em>weather condition</em>. K is set
to the type, and then K is used in the body of the function in the same
places and same ways as the word itself would have appeared. The feature
is also very useful in typecasting, via Inform 6.</p>

<div class="codeblock">
<div class="codeline">To rattle off all the (<strong>name of kind of value</strong> K):</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;repeat with x running through K:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;say "[x], "</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">To decide which K is the (mystery - a value) as a (<strong>name of kind of value</strong> K):</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;<code>(- {mystery} -)</code>.</div>
</div>

<p>We can then write:</p>

<div class="codeblock">
<div class="codeline">rattle off all the scenes;</div>
<div class="codeline">rattle off all the tattoos;</div>
<div class="codeline">rattle off all the rooms;</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">let whatsit be foobar as a tattoo;</div>
<div class="codeline">let whosit be foobar as a person;</div>
<div class="codeline">let howsit be foobar as a rule;</div>
<div class="codeline">let whensit be foobar as a scene;</div>
</div>

<p>And so on. Most OO languages tend to treat everything as an
instantiation of a class. In Inform, many constructs are not objects,
but the type system allows us to use the same function on everything
just the same. (Note that parameter types <em>condition</em> and
<em>action</em> are still a special case. They can only be used in a
phrase when the body is written in Inform 6. The later chapter on Inform
6 covers them.)</p>

<p>To-phrases and relations can be passed as parameters, but still
strongly-typed. Examples of the type of a phrase would be:</p>

<div class="codeblock">
<div class="codeline">a phrase (length, length) -> nothing</div>
<div class="codeline">a phrase nothing -> number</div>
<div class="codeline">a phrase (number, number) -> number </div>
</div>

<p>And for relations:</p>

<div class="codeblock">
<div class="codeline">a one-to-various relation of people to cars [ asymmetric is always assumed ] </div>
<div class="codeline">a symmetric one-to-one relation of people ["to people" is assumed]</div>
<div class="codeline">an equivalence relation of people</div>
</div>

<p>One thing Inform cannot do is an indefinite number of parameters,
such as the printf function in the C programming language. And because
Inform is strongly typed, there must be a slew of phrases that apply a
passed-in phrase to 1, 2, or 3 inputs, and returning a value or not. For
phrases that return a value, use one of <em>(phrase) applied</em>, or
<em>(phrase) applied to (value)</em>, or <em>(phrase) applied to
(value1) and (value2)</em>, up to three parameters, just like rules. For
phrases that do not return a value, <em>apply (phrase)</em>, or
<em>apply (phrase) to (value1)</em>, etc.</p>

<p>In lieu of indefinite parameter counts, Inform can pass around lists
of whatever, and has the higher-order functions. Map, as <em>(phrase)
applied to (list)</em>, takes a list, runs the passed-in phrase on each
element in turn, and returns the new list. Filter, as <em>filter to
(description) of (list)</em>, returns a smaller list than the one passed
in, having removed what elements don't fit the set-description. And
reduce, as <em>(phrase) reduction of (list)</em>, which returns a single
value.</p>

<p>However, these only emulate the syntax of functional programming.
Without lazy evaluation or anonymous functions, this style of
programming leaves much to be desired, and cannot at all deal with lists
of infinite size in the common generator-consumer pattern.</p>

<h2 id="sweet-relations">Sweet Relations</h2>
<p>In lieu of numerical relationships, qualitative either/or
relationships frequent interactive fiction. Relations disguise 2D
boolean arrays behind some of the best syntactic sugar in the language
&ndash; namely, behind verbs. Relations are written with the infix form of
English verbs. Asymmetric (<em>X to Y</em>) and symmetric (<em>X to
[one] another</em> or <em>X to each other</em>) relations are possible,
with one-to-one, one-to-various, various-to-one, and various-to-various
flavors, plus the equivalence relation (<em>[various] X to each other in
groups</em>). The <em>called</em> parenthetical, only on a singular
side, allows property syntax as well.</p>

<div class="codeblock">
<div class="codeline">Marriage <strong>relates</strong> <em>one</em> person <strong>to</strong> <em>another</em> <strong>(called</strong> the spouse<strong>)</strong>. [ one-to-one symmetric ]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>The verb to</strong> be married to <strong>implies</strong> the marriage relation.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Bob is married to Jane.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">When play begins, if Jane is married to someone, say "Jane's husband is [the spouse of Jane]." [ prints Bob ]</div>
</div>

<p>Symmetric relations are always of type X to type X. So marriage
cannot be "one man to one woman" nor can friends be anything but person
to person.</p>

<div class="codeblock">
<div class="codeline">Friendship <strong>relates</strong> people <strong>to</strong> <em>each other</em>. [various-to-various, symmetric]</div>
<div class="codeline"><strong>The verb to</strong> be friends with <strong>implies</strong> the friendship relation.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">if the brother of the noun <strong>is married to</strong> the second noun, now the noun <strong>is friends with</strong> the second noun;</div>
<div class="codeline">repeat with pal running through every person who <strong>is friends with</strong> the brother of the noun: [...]</div>
</div>

<p>When we define a verb like <em>to be X</em>, Inform can automatically
conjugate it. But for <em>to X</em> we supply the other five forms in
parenthesis. They are, in order, the singular (-s), plural (root), past
(-ed), past participle (-en), and present participle (-ing). At least
either the singular or plural must be supplied. <em>He/she/it</em> may
be used interchangeably, but <em>they</em> has no synonym.</p>

<div class="codeblock">
<div class="codeline">Like-minded <strong>relates</strong> <em>various</em> people <strong>to</strong> <em>each other in groups</em>. [ an equivalence relation ]</div>
<div class="codeline"><strong>The verb to</strong> draw (he draws, they draw, it drew, he is drawn, she is drawing) <strong>implies</strong> the like-minded relation.</div>
</div>

<p>Asymmetric relations may find a <em>reversed</em> synonym useful in
set-descriptions.</p>

<div class="codeblock">
<div class="codeline">Teenage love <strong>relates</strong> <em>various</em> people <strong>to</strong> <em>various</em> people. [ tragically, an asymmetric relation ]</div>
<div class="codeline"><strong>The verb to</strong> be in love with <strong>implies</strong> the teenage love relation.</div>
<div class="codeline"><strong>The verb to</strong> be lusted after <strong>implies</strong> the <strong>reversed</strong> teenage love relation.</div>
</div>

<p>Additionally, we can define the verb as <em>to be able to X</em>,
which means the relation is used like <em>can X</em>. The parenthetical
has only the past participle (-en) form, and is required.</p>

<div class="codeblock">
<div class="codeline">Memorability <strong>relates</strong> <em>various</em> people <strong>to</strong> <em>various</em> things.</div>
<div class="codeline"><strong>The verb to</strong> <em>be able to</em> remember (he is remembered) <strong>implies</strong> the memorability relation.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Bob is a man.</div>
<div class="codeline">The time he spent in jail is a thing.</div>
<div class="codeline">Bob <strong>can remember</strong> the time he spent in jail.</div>
</div>

<p>The <em>to be able to&hellip;</em> relations (only) can be stated in the
passive voice as well. So <em>Bob can remember jailtime</em> may be
stated <em>jailtime can be remembered by Bob</em>. Effectively, the
<em>reversed</em> version is provided automatically. The phrasebook part
of the Index shows the available wordings.</p>

<p>Though only an asymmetric various-to-various relation actually needs
a whole 2D array, the other kinds of relations are some sort of subset
of one. Any relation with a singular is frequently implemented as a
property, as are equivalence relations. Relations on very large (text)
or infinite (numbers) domains will use sparse array implementations,
such as properties whose type is a list of some sort.</p>

<p>Much like boolean adjectives, relations can be implemented as
calculation rather than storage.</p>

<div class="codeblock">
<div class="codeline">Siblinghood <strong>relates</strong> a person <strong>(called</strong> X<strong>) to</strong> a person <strong>(called</strong> Y<strong>) when</strong> X is the brother of Y or X is the sister of Y.</div>
<div class="codeline"><strong>The verb to</strong> be a sibling of <strong>implies</strong> the siblinghood relation.</div>
</div>

<p>The syntax to check whether a relation holds between two things is
the same regardless the implementation, so swapping between them only
requires fixing up wherever the relation was explicitly set between
things. It is worth nothing that the relativistic relations of math are
implemented this way ("The verb to be greater than implies the&hellip;") as
well as almost all spatial relations (under, on, in, northeast of,
etc.)</p>

<p>Relations can be put into lists, or passed into functions.</p>

<div class="codeblock">
<div class="codeline">To decide whether (relationship - a <strong>symmetric various-to-various relation of people to people</strong>) is a good reason for trusting (P - a person):</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;decide on whether or not <strong><em>relationship</em> relates <em>P</em> to <em>the player</strong></em>.</div>
</div>

<p><em>Asymmetric</em> is assumed, so only <em>symmetric</em> is
defined. The <em>one-to-various</em> and flavors obviously cannot be
used with <em>equivalence</em>. Finally, <em>empty</em> describes the
default condition. The phrase <em>relates&hellip;kto&hellip;</em> can be used in
<em>if</em> and <em>now</em> statements. In an <em>if</em>, types and
negation can be used: <em>if Bob <strong>does not relate to</strong>
someone <strong>by</strong> the love relation.</em></p>

<p>Note that the above phrases and the following phrases are indeed
<em>phrases</em>, not a set-description (which the following resemble)
nor a three-way relation (which the former resemble, assuming Inform
could even do multi-way relations).</p>

<p>Various functions provide lookup. These are especially handy when
dealing with domains as large as text or numbers. Unfortunately, the
compiler cannot check them at compile-time. Runtime type errors result
if arguments are swapped.</p>

<div class="codeblock">
<div class="codeline">a Y which X relates to by R [ for various-to-one or one-to-one ] </div>
<div class="codeline">a X which relates to Y by R [ for one-to-various or one-to-one ]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">list of Ys which X relates to by R [ for various and equivalence ]</div>
<div class="codeline">list of Xs which relate to Y by R [ for various and equivalence ]</div>
<div class="codeline">[ Warning: the above two are new and very buggy. ]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">list of Xs which R relates [ for finding everything on the left hand side of relation R ]</div>
<div class="codeline">list of Ys which R relates to [ for finding everything on the right hand side of relation R ]</div>
</div>

<p>Pathfinding uses relations.</p>

<div class="codeblock">
<div class="codeline">let X be <strong>the number of steps via</strong> the acts with relation <strong>from</strong> Kevin Bacon <strong>to</strong> Jodie Foster;</div>
<div class="codeline">let S be <strong>the next step via</strong> the acts with relation <strong>from</strong> Christopher Walken <strong>to</strong> Kevin Bacon;</div>
</div>

<p>And of course, relations are integral to set-descriptions. Since
set-descriptions can be parameter types in functions, procedures, rules,
and understand tokens, and be a domain description in <em>repeat</em>
loops and <em>now every</em> assignment statements, as well as passed-in
and used in their own right to phrases like <em>filter</em>, they are
the secret sauce which COBOL and Applescript lack.</p>

<div class="codeblock">
<div class="codeline">repeat with countrymen running through <strong>every resourceful not antagonistic person who trusts the player who is friends with a person (called the shill) who owns a thing (called riches):</strong></div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "Hi [countrymen]. [Shill] said you'd lend me your [riches]."</div>
</div>

<p>In the above description, each subordinate phrase applies to the main
noun &ndash; person, in this case &ndash; not to the nouns listed in other
subordinate phrases &ndash; such as player, thing, or the second person.
(Asking "who is friends with a person" is a way of asking who has
friends.) We cannot insert commas or conjunctions ("and").</p>

<h2 id="rules-of-thumb">Rules of Thumb</h2>
<p>Because interactive fictions are single-author artworks rather than
team-designed workhorses, novelty and ease of modification trump safety
and scalability. As a result, a partially rule-based paradigm was
chosen. Where the procedural paradigm triggers imperative code blocks by
invoking that code's given name (the name-plus-code construction is
called a procedure or function), the rule-based paradigm triggers
imperative code blocks by attaching situational information to it. The
situational condition is called the preamble, and the preamble-plus-code
construction is called a rule.</p>

<p>In other words, a rule encapsulates <em>when</em> its code executes.
For a procedure, the information about when it executes is spread
diffusely over the source code: wherever its name appears. Rules
typically don't need names because rules already know when they execute.
They needn't be told so by other code. (Rules can be named, as the
following example shows, and we'll soon see some reasons for doing
so.)</p>

<div class="codeblock">
<div class="codeline">A carry out rule for someone playful (called the prankster) which is friends with the player inserting a favorite something into something worn when the time of day is before the deadline during the opening scene (<strong>this is the</strong> my fairly long <strong>rule</strong>):</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;Now the prankster annoys the player.</div>
</div>

<p>We have already dissected two rules so far in this guide, one in the
nutshell chapter and one in the firehose chapter, so let's move a little
faster through this one. <em>Carry out</em> would be the rulebook name,
except that <em>check</em>, <em>carry out</em>, and <em>report</em> are
actually each multiple rulebooks, one set for each action. So the
rulebook in use here might be named <em>carry out inserting it
into</em>. <em>A</em> and <em>rule for</em> are just syntactic sugar,
and ignored by the compiler. The first parameter, the performer, must
match the set-description <em>someone playful which is friends with the
player</em>, and if so, the variable <em>prankster</em> captures.
<em>The noun</em> will hold what matched <em>a favorite thing</em> while
<em>the second noun</em> will hold what matched <em>something worn</em>.
The <em>when</em> condition must be satisfied and a scene, <em>the
opening scene</em>, must be currently in progress. We also name this
rule <em>my fairly long rule</em>, so further work may be done on this
rule, such as temporarily ignoring it at run-time via an extension, or
placing constraints about its placement in its rulebook vis-a-vis the
other rules in it. The colon begins the imperative code block, and the
period ends the imperative code block. In short, the rule defines in
what situation that the player will be annoyed by someone.</p>

<p>In Prolog the rule would be written the other way around: <em>The
prankster annoys the player if-and-only-if the action is the inserting
it into action, and the actor is a person, and the actor is playful, and
the actor is friends with the player, and the noun is a thing, and the
noun is a favorite, and&hellip;</em> and so on, in its verbose, obtuse,
punctuation-filled way. Neither COBOL nor Applescript are even that
sophisticated. Indeed, one of the better analogs for Inform's rules are
the rules of Perl 6, even though Perl's rules are intended primarily for
text strings and grammar.</p>

<p>A few short examples of rule preambles follow. The latter three have
the imperative block included as well.</p>

<div class="codeblock">
<div class="codeline">A persuasion rule: [...]</div>
<div class="codeline">Persuasion: [ an identical preamble to the above ] </div>
<div class="codeline">Every turn: [...]</div>
<div class="codeline">Every turn during the collapsing bridge scene: [...]</div>
<div class="codeline">Report someone burning something: [...]</div>
<div class="codeline">Instead of burning something held (this is the safety first rule): say "No, you might burn yourself!".</div>
<div class="codeline">Carry out <strong>an actor</strong> helping someone: now the noun befriends the actor. [ <em>an actor</em> means anyone; <em>an</em> is required ]</div>
<div class="codeline">Report tattooing: say "You go to work on [the second noun]'s [the limb understood].".</div>
</div>

<p>Unlike Prolog's never-ending sea of rules, Inform groups its rules
into rulebooks. When a rulebook is invoked, only that rulebook's rules
are considered. The only required part of a rule's header is the
rulebook to which it belongs, though additional clauses are frequently
attached using <em>during</em> (for scenes), <em>when/while</em> (for
<em>if</em> conditions), and a sole action description (such as
<em>someone cutting something</em>) immediately following the rulebook
name. This allows rulebooks to encapsulate smart, mutable behavior,
similar to objects, but behavior here is paramount, not a data
instantiation. It could be said that objects implement nouns while
rulebooks implement verbs.</p>

<p>In source code, a rulebook's rules are rarely found together or in
any particular order. They can be scattered all over the source code,
sprinkled throughout extensions, etc. An author is free to group his
rules however he wishes, such as by the narrative scene or geographical
area in which they're used, or by the rulebook to which they belong, or,
yes, by the object(s) to which they apply.</p>

<p>There are a few cases where naming a rule is useful, but these are
usually in addition to the header, not in spite of it. One is in
debugging output: the RULES and RULES ALL testing commands list the
names of rules as they execute, or are considering execution,
respectively. Two is the ability to put the rule into a rule variable or
passing the rule to a phrase. Three, rarely, is imperatively invoking a
particular rule. Four, especially for extension authors, is so other
rules may be listed before, after, or instead of the named rule at
compile time. Finally is the sake of documentation, primarily the
index.</p>

<div class="codeblock">
<div class="codeline">The block sleeping rule <strong>is not listed in</strong> <em>any rulebook</em>.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">My magic hand rule <strong>is listed instead of</strong> the can't take distant objects rule <strong>in</strong> the check taking rulebook.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">The landlubbers can't walk right rule <strong>is listed first in</strong> the check going rules.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>This is the</strong> my foobar <strong>rule:</strong></div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;say "Someone please invoke me imperatively or list me <em>instead of</em> another rule!"</div>
</div>

<p>But rules aren't functions. The latter example names a rule but gives
it no preamble and no containing rulebook. Unless <em>my foobar
rule</em> is itself used in a line like the preceding two, or is
directly invoked with <em>follow</em>, it's dead code. The named but
preamble-less rule implies we are thinking too procedurally. Whatever
invokes that rule is itself invoked at a particular time under
particular circumstances, so those circumstances should be in the
preamble. Even if the rule is invoked from multiple places, at least one
place can use the preamble.</p>

<p>Strictly speaking, a rule accepts only one parameter, as defined by
its rulebook, while all else in the rule's preamble comes from global
variables &ndash; the world-state. (Even more strictly: at the Inform 6
level, the parameter itself is actually in the global variable
<em>parameter_object</em> and rules become functions taking zero
parameters.) However, the default type of a rulebook is <em>a
description of actions,</em> which itself accepts at most three noun
parameters, each of which could be a set-description. Since most of the
commonest rulebooks do this, rules seem to have a higher arity than they
really do. Furthermore, a rule can optionally return one value, via
<em>rule succeeds with result</em>, the type of which is defined by its
rulebook. All of the standard rulebooks produce nothing, which further
muddies the true nature of rules: as a kind of codec, filter, or
transformation which accepts the world-state in a particular state,
possibly prints something, and possibly changes the world-state as it
finishes.</p>

<p>So to make a long story short: when a rulebook is <em>K based</em>,
then rules belonging to it are written <em>rulebook-name
instance-of-K</em>, and even then the instance is optional.</p>

<div class="codeblock">
<div class="codeline">Snark is a <strong>text based</strong> rulebook.</div>
<div class="codeline">Snark "your mother was a hamster": [...]</div>
<div class="codeline">Snark "silly English k-nigget" during the siege of the French castle: [...] Last snark: [...]</div>
<div class="codeline">The last snark rule: [...]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Spell out is a <strong>number based</strong> rulebook.</div>
<div class="codeline">Spell out 15: [...]</div>
<div class="codeline">Spell out: [...]</div>
<div class="codeline">Spell out 2 during relationship counseling: [...]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Juggle is an <strong>object based</strong> rulebook.</div>
<div class="codeline">Juggle the hamster: [...]</div>
<div class="codeline">Juggle an animal when PETA is not in the location: [...]</div>
<div class="codeline">The first juggle something (called the whatsit) when the player does not carry the whatsit: [...]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Ms Manners approves is a rulebook. [ basis is missing, so <em>a description of actions</em> it shall be ]</div>
<div class="codeline">Ms Manners approves someone nice wearing something nice: [...]</div>
</div>

<p>So let's examine rulebooks now, as they drive what a rule can,
should, and cannot do, including defining the apparent syntax even if
the grammar is identical in all cases.</p>

<h2 id="rulebooks-white-box-paradigm">Rulebooks: White-box Paradigm</h2>
<p>Like a function, a rulebook solves what task is given it. Unlike a
function, a rulebook picks and chooses which rules within itself to
execute. It will execute its rules until one of them produces a success
or failure result, distinct from any (optional) returned value. In lieu
of a return statement, rules use one of the <em>rule succeeds [with
result X]</em>, <em>rule fails</em>, or <em>make no decision</em>
imperatives, the last of which tells the 'book to try the next rule for
a result. If a rule ends without one of these three imperatives, the
default imperative &ndash; usually <em>make no decision</em> &ndash; is invisibly
added at the end of every rule. That default is set by the rulebook.</p>

<div class="codeblock">
<div class="codeline">The pick a plan rules <strong>are a rulebook</strong>.</div>
<div class="codeline">The pick a plan rules <strong>have default outcome</strong> <em>success</em>. [ Or <em>failure</em>, or <em>no outcome</em> ]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">A pick a plan rule:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "I always fail, regardless the rulebook's default.";</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;<strong>rule fails</strong>.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">A pick a plan rule:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "I can never make up my mind so one of my peers will now execute.";</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;<strong>make no decision</strong>.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">A pick a plan rule:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "I exhibit the default behavior for the rulebook."</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">A pick a plan rule:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "I'm always a winner.";</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;<strong>rule succeeds</strong>.</div>
</div>

<p>A rulebook can take up to one parameter (including one whole
action-description) and <em>produce</em> one return value. A rulebook is
invoked in one of several ways, mainly depending on whether it takes a
parameter and whether it produces a value. These phrases are</p> 
  <p><ol class="num"><li><em>follow (rulebook)</em></li>
    <li><em>follow (rulebook) for (value)</em></li>
    <li><em>the (value) produced by (rulebook)</em></li>
    <li><em>the (value) produced by (rulebook) for (value)</em></li></ol></p>

<div class="codeblock">
<div class="codeline">A snarky one-liner is <strong>a <em>rule</em> based rulebook producing <em>text</strong></em>. [<em>rulebook</em> by itself is <em>action based producing nothing</em>]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">When play ends, say <strong>the <em>text</em> produced by <em>snarky one-liner</em> for <em>the reason the action failed</strong></em>.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>Snarky one-liner for</strong> the shouldn't touch electrical wires rule:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;<strong>rule succeeds with result</strong> "You ignored the No Trespassing sign? I'm... shocked."</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>Snarky one-liner for</strong> the shouldn't descend deep dark wells rule:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;<strong>rule succeeds with result</strong> "Good news! You have a choice: drowning or landing."</div>
</div>

<p>The remaining ways all substitute <em>follow</em> for either
<em>abide by</em> or <em>anonymously abide by</em>. Both of these return
immediately after their called rulebook returns. The only difference is
the latter not setting the rule variable <em>the reason the action
failed</em> to itself, becoming a silent middle-man. Finally, <em>rule
succeeded</em> and <em>rule failed</em>, the past tense versions of
<em>rule succeeds</em> and <em>rule fails</em>, are used in <em>if</em>
statements to see if their present tense counterparts ended the recently
called rulebook. This information is stored just above the current stack
pointer, so calling any functions &ndash; including things which become
functions in Inform 6, such as set-descriptions &ndash; will clobber
them.</p>

<div class="codeblock">
<div class="codeline">Check planning:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;<strong>follow</strong> the pick a plan rules; </div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;if the <strong>rule succeeded</strong>:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;say "Rulebook succeeded.";</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;otherwise if the <strong>rule failed</strong>:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;say "I've no plans because of [<strong>the reason the action failed</strong>]." instead;</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;otherwise:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;say "Not a single applicable rule could make up its mind."</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Check planning (this is the choose-a-plan rule):</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;<strong>abide by</strong> the pick a plan rules;</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "This only prints if the pick a plan rule <em>make no decision</em>. But if it did succeed or fail, <em>abide by</em> returns, setting <em>the reason the action failed</em> to this choose-a-plan rule."</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Check planning (this is the choose-a-plan rule):</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;<strong>anonymously abide by</strong> the pick a plan rules;</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "As above, but <em>the reason the action failed</em> will still be set to a rule in the pick a plan rulebook even upon success and failure. This choose-a-plan rule is a silent middle-man."</div>
</div>

<p>One way to think of rulebooks is as callbacks. More restricted
languages, especially C when talking to an operating system's API, use
what are called callbacks to "insert" user-written code into an
operating system or library. Typically, callbacks are a bit arcane. C is
notorious for tangling pointers like spaghetti, so pointers-to-functions
&ndash; which is what callbacks are &ndash; can be a recipe for cyanide. But
Inform's problem domain of iconoclastic games, which thrive at least in
part on novelty, places heavy demands on the flexibility of any standard
library. Callbacks are the norm, not the exception. Whence comes
rulebooks: "open" spaces where rules may be inserted and/or swapped out.
So instead of code resembling this:</p>

<div class="codeblock">
<div class="codeline">The callback rules are a rulebook. [usually empty]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">To foobar:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;ponder foo;</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;follow the callback rules;</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;mull over bar.</div>
</div>

<p>&hellip; the pattern becomes this:</p>

<div class="codeblock">
<div class="codeline">The foobar rules are a rulebook.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Foobar rule (this is the pre-callback work rule): ponder foo. </div>
<div class="codeline">Foobar rule (this is the post-callback work rule): mull over bar.</div>
</div>

<p>And now client code may insert code in a variety of places, even
replacing the imperative sections if desired.</p>

<p>To further strengthen the tie between rulebooks, functions, and
natural language, rulebooks may have "named outcomes". These are a set
of imperative phrases and a set of named values which work in concert.
The outcome identifier by itself is the imperative, which is syntactic
sugar for <em>rule succeeds with result [corresponding named
value]</em>. The named value set each have the word <em>outcome</em>
appended (except when printing) and fill-in the variable <em>the outcome
of the rulebook</em> for use in the caller's code. Outcomes can be
classified as success or failure as well.</p>

<div class="codeblock">
<div class="codeline">The audible rules <strong>have outcomes</strong> silent (failure), whispered (success), voiced (success - the default), and deafening.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">[...]; whispered. [ synonymous with <em>rule succeeds with result the whispered outcome</em> ]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">follow the audible rules;</div>
<div class="codeline">if <strong>the outcome of the rulebook</strong> is not the silent outcome, say "You heard something [<strong>outcome of the rulebook</strong>]."</div>
</div>

<p>Named outcomes are most useful for extensions and the standard
library. Much as boolean object properties are a pair of named values
(like <em>lit/unlit</em>) belonging to an anonymous property, rather
than a named property (like isLighted) holding true or false, rulebooks
can provide easily remembered decision phrases for new, author-written
rules.</p>

<div class="codeblock">
<div class="codeline">Visibility when the player carries at least two lit candles: <strong>there is sufficient light</strong>.</div>
<div class="codeline">Does the player mean taking the train: <strong>it is very likely</strong>. [ "getting on" or "entering" the train, perhaps ]</div>
<div class="codeline">For deciding whether all includes the kitchen sink: <strong>it does not</strong>.</div>
<div class="codeline">For reaching inside a closed tiger cage: <strong>allow access</strong>. [ foolish, but possible ]</div>
</div>

<p>Rulebooks may also have local variables. Unlike <em>let</em>
variables which end with the code block, these remain in scope over all
the rules of the 'book. Though we don't have a specific way of
initializing them like <em>let</em> does, we can use the rule ordinal
<em>first</em> to put a particular rule at the start of a rulebook.
(Only <em>first</em> and <em>last</em> exist this way, and in cases of
multiple rules using them, only the final <em>first</em> or
<em>last</em> rule actually is so, superseding the preferences of
earlier rules that use them.) <em>Last</em> rules are useful for
providing a fallback.</p>

<div class="codeblock">
<div class="codeline">The pick a plan rulebook <strong>has</strong> <em>a rule</em> <strong>called</strong> the best plan.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">The <strong>first</strong> pick a plan rule (this is the initialize plan rule): now the best plan is the little-used do nothing rule.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">The <strong>last</strong> pick a plan rule (this is the no idea rule): rule fails.</div>
</div>

<p>A few odds and ends before we close the chapter. <em>Stop the
action</em> is synonymous with <em>rule fails</em>, and <em>continue the
action</em> is synonymous with <em>make no decision.</em> The word
<em>rules</em> is synonymous with <em>rulebook</em> in the source code,
and is possibly the only case in the language where a singular
(<em>rule</em>) and its plural (<em>rules</em>) do not mean the same
thing. (In practice, this exception is fairly natural.) Finally, a rule
variable can hold a rule and/or rulebook, but a rulebook variable can
only hold a rulebook.</p>

<h2 id="events-are-actions">Events are Actions</h2>
<p>In interactive fiction, the player controls the protagonist, and
typed commands translate into actions within the fictional universe.
Protagonist actions like <em>looking</em>, <em>examining</em>, or
<em>burning</em> have rulebooks to deal with those events. Specifically,
three rulebooks comprise an action: its <em>check</em> rulebook ensures
the action can proceed; its <em>carry out</em> rulebook updates game
state; and its <em>report</em> rulebook narrates the result. The other
rulebooks that hinge on an action, such as <em>instead</em>, these three
are created anew for each action in the game. There isn't one
<em>check</em> rulebook; there are many, one for each action. This is
done partly for performance reasons, and partly for sanity reasons: to
avoid a "sea of rules".</p>

<div class="codeblock">
<div class="codeline">Check taking something held: say "You already have that." instead.</div>
<div class="codeline">Carry out an actor taking something: now the actor carries the noun.</div>
<div class="codeline">Report taking: say "Taken." instead.</div>
</div>

<p>Much of Inform programming is writing report rules for actions,
though some game events like <em>every turn</em>, <em>printing the
name</em>, and <em>when play begins</em> are also popular. (Game events
usually comprise a single rulebook apiece unless they are
<em>activities</em>, which we will see shortly.)</p>

<p>Defining a new action is similar to a function prototype. The exact
wording <em>is an action</em> is required. Furthermore, at least one
"parameter" must be given: <em>whining is an action</em> is disallowed
without some more information. However, Inform doesn't much care what
that information is: supplying a past participle is just as good as the
<em>applying</em> arity and type specification. <em>Applying to
nothing</em> is assumed if it is dropped.</p>

<div class="codeblock">
<div class="codeline">Donating <strong>is an action</strong> applying to one thing.</div>
<div class="codeline">Discussing <strong>is an action</strong> applying to one topic.</div>
<div class="codeline">Accusing it of <strong>is an action</strong> applying to one object and one visible object.</div>
<div class="codeline">Tabulating <strong>is an action</strong> applying to one number and requiring light.</div>
<div class="codeline">Scheduling <strong>is an action</strong> applying to one time.</div>
<div class="codeline">Temporarily waiting <strong>is an action</strong> applying to one time.</div>
<div class="codeline">Whining <strong>is an action</strong> applying to nothing.</div>
<div class="codeline">Teleporting to <strong>is an action</strong> applying to one object. [<em>room</em>, to be specific]</div>
<div class="codeline">Debugging some stuff <strong>is an action</strong> out of world applying to nothing.</div>
<div class="codeline">Tattooing it of <strong>is an action</strong> applying to one limb and one thing, requiring light.</div>
<div class="codeline">Weaving <strong>is an action</strong> with past participle woven, applying to one thing.</div>
</div>

<p>These each create the three rulebooks that will hold the
implementation details. Because actions implement an English verb that
our player-character (or an NPC) will perform, verbs have a maximum
arity of three and a minimum arity of one. The subject, called <em>the
actor</em> (or, as a global, <em>the person asked</em>), is required so
no mention is made. In the implementation, the direct and indirect
objects of a sentence are called <em>the noun</em> and then <em>the
second noun</em> &ndash; but only if they are objects. Otherwise, the
variable is <em>the number understood</em>, <em>the time
understood</em>, <em>the topic understood</em>, etc.</p>

<p>The syntax for declaring actions is very special-case. The phrase
<em>requiring light</em> refers to a worldsim precondition. The
adjective <em>visible</em> places every object (such as intangible ideas
and rumors) in scope, and is completely unrelated to <em>requiring
light.</em> The word <em>thing</em> (or <em>things</em>) actually means
any objects &ndash; we can't be more specific with <em>person</em>, for
example. (However, it does accept <em>object</em> as a synonym, oddly
enough.) The phrase <em>out of world</em> is for system-level actions,
which skips a great deal of the worldsim's calculations. <em>With past
participle X</em> tells Inform to use that word in source code for the
past participle (<em>has woven</em> for example) instead of replacing
the -ing suffix with an -ed suffix automatically. And finally, other
types such as topic, time, time period, number, and various units may
each only be used once in an action.</p>

<p>After an action is created, the action must be implemented with
rules, and then the parser must be pointed to it via Understand
statements. If the parser is not pointed at it, an action can still be
invoked from the code, via <em>try</em>, <em>try silently</em>, and
<em>silently try</em>. When tried <em>silently</em>, the <em>report</em>
rules are skipped entirely.</p>

<div class="codeblock">
<div class="codeline"><strong>try</strong> Bob donating the jeans;</div>
<div class="codeline"><strong>silently try</strong> donating the red Ferrari;</div>
<div class="codeline"><strong>try</strong> Bob accusing the player of theft;</div>
<div class="codeline"><strong>try</strong> teleporting to the tattoo parlor; [subject can be dropped when "the player" performs the action]</div>
<div class="codeline"><strong>try</strong> silently the current manager tattooing the back of the player;</div>
</div>

<p>For actions with two objects, at least one word (such as a
preposition) is needed between the parameters, and the word <em>it</em>
is a placeholder for the first parameter. <em>It</em> tells Inform where
the first parameter goes, because actions with multi-part names like
<em>teleporting to it by way of</em> have too many choices
otherwise.</p>

<p>Finally, an action invocation can be put into a variable of type
<em>stored action</em> and invoked at a later time. The phrase <em>the
action of</em> must precede the invocation in order to capture it.</p>

<div class="codeblock">
<div class="codeline">An abeyance is a stored action that varies.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">[...]; now the abeyance is <strong>the action of</strong> Bob examining the player;</div>
<div class="codeline">[...]; try the abeyance;</div>
<div class="codeline">[...]; now abeyance is <strong>the action of</strong> the current manager firing the noun;</div>
</div>

<p>The parts of the stored action can be reached with syntax similar to
object properties: <em>the actor part of, the action name part of, the
noun part of,</em> and <em>the second noun part of</em>. Stored actions
are easy to create when only the nouns vary: just use variables like
<em>the current manager</em>. But to assign to the <em>action name</em>
part the extension Editable Stored Actions is necessary. A built-in
<em>to decide</em> function, <em>the current action</em>, returns the
currently-executing action as a stored action. (Syntax note: very
occasionally, the compiler will have difficulty parsing an invocation
that has a NPC as a subject. In these cases, add the word
<em>trying</em> before the action: <em>Bob trying examining the
player</em>.)</p>

<p>Processing a character's action is a multi-step process, not
including parsing. Each step is its own rulebook. And just to be clear,
every action has its own <em>check</em>, <em>carry out</em>, and
<em>report</em> rulebook. The others are shared among all actions. The
following outline shows the rulebooks chronologically, marking the
NPC-only rulebooks with the Thalia and Melpomene masks: üé≠ .</p>

<p>
  <ul class="action-rulebooks" role="list">
<li><span class="list-entry">Setting Action Variables</span></li>
<li><span class="list-entry">Before</span></li>
<li class="npc"><span class="list-entry">Persuasion [ NPCs only ]</span></li>
<li><span class="list-entry">Instead [ default outcome is failure, so only one rule will
typically execute before jumping to the end ]</span></li>
<li><span class="list-entry">Check [action]</span></li>
<li class="npc"><span class="list-entry">Unsuccessful Attempt By [ only when Instead or Check fails ] [
NPCs only ]</span></li>
<li><span class="list-entry">Carry out [action]</span></li>
<li><span class="list-entry">After [ default outcome is success, so only one rule will typically
execute before jumping to the end ]</span></li>
<li><span class="list-entry">Report [action] [ skipped if the action was invoked with <em>try
silently</em> ]</span></li>
</ul>
</p>

<p>Each rulebook has its task:</p>

<p><em>Check</em> rulebooks catch situations which should prevent an
action from occurring. It enforces preconditions, essentially. If the
check rules prevent the player from doing something, it is responsible
for narrating that result. So a typical check rule reads like, "if X,
then say Y and abort action."</p>

<p><em>Carry out</em> rulebooks simulate the action, updating any data
and running any code necessary. It should not print anything lest
<em>try silently</em> won't live up to its name.</p>

<div class="codeblock">
<div class="codeline">Carry out an actor jumping: now the actor is on the nearby platform. ["an actor" applies to everyone]</div>
</div>

<p><em>Report</em> rulebooks then narrate the result of the successful
action. Usually the say statements in a report rule should end with
<em>instead</em> to prevent multiple report rules from running. The
action is already considered to have succeeded by this point, so the
usual meaning of <em>instead</em> as failure isn't significant.</p>

<div class="codeblock">
<div class="codeline">Report someone jumping: say "You see [the actor] jump over." ["someone" applies to any NPC]</div>
<div class="codeline">Report jumping: say "You jump over." [subject-less means the player]</div>
</div>

<p><em>Persuasion</em> decides, upon a player command like BOB, TAKE
ROCK, whether Bob will do as you ask him to. The default
<em>persuasion</em> rule, written in Inform 6 and so omitted from the
Actions index, denies with "Bob has better things to do."</p>

<p><em>Unsuccessful attempt by</em> runs if Bob agreed to what was asked
of him, but a <em>check</em> or <em>instead</em> rule stopped him. It
exists so the author may narrate failure better than the default, "Bob
is unable to do that." Again, the default rule is written in Inform 6,
so is omitted from the Actions index.</p>

<p><em>Before</em> happens between parsing and game reaction. It can
also trigger on groups of actions. It's useful for setting up variables
or other miscellaneous situations before the action rules begin in
earnest.</p>

<p><em>Instead</em> is useful for blocking groups of actions. This is a
favorite of most new authors, and it's not hard to see why. It can apply
to groups of actions or a single action, one-liner versions can use the
comma for great readability, it defaults to <em>rule fails</em> so
writing a rule here can handle an entire situation on its own if
desired. Unfortunately, <em>instead</em> rules tend to get used for
everything, which is a bad coding practice because there are knock-on
effects later. For example, the system thinks every rule fails, so
tensed conditions like <em>if we have examined the red book</em> will
fail, even though we have, in fact done so. The author's prose came from
an <em>instead</em> rule instead of a <em>report</em> rule.</p>

<div class="codeblock">
<div class="codeline">Instead of Tiny jumping: say "Tiny is too overweight to jump. You all must find another way to help him across."</div>
</div>

<p><em>After</em>, when adorned with a condition or three, is useful for
triggering cutscenes. It defaults to <em>rule succeeds</em>, so the
report rules aren't run afterward. Again, they tend to get used often
for the same reasons as <em>instead</em>.</p>

<p><em>Setting action variables</em> should do as little as possible,
and is rarely needed. It's intended to initialize variables that are
local to an action, as opposed to variables local to an individual
rulebook or rule, by pulling values from global variables and object
properties, including the parameters <em>the actor</em>, <em>the
noun</em> and <em>the second noun</em>. When declaring an action-local
variable, an optional "matched as" parenthetical allows rules in the
rest of this action's gauntlet to test those variables similarly to how
it tests on the actual parameters. It isn't a way to pass additional
parameters to a rule, only to check world-state readably. The standard
<em>going</em> action uses this to provide rule hooks like <em>going
to/from [a room], going through [a door], going by [a vehicle]</em>,
etc.</p>

<div class="codeblock">
<div class="codeline">Report <strong>going from <em>the monkey village</em> to <em>the lost city's entrance</em> by <em>the hoverboard</strong></em>:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "You sail into the clearing easily this time, bypassing all those nasty monkeys that like to drop on top of you." instead.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">The jumping action <strong>has</strong> an object <strong>called</strong> the obstacle <strong>(matched as</strong> "over"<strong>).</strong> [ <em>Matched as</em> must be a single word. ]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>Setting action variables</strong> for jumping: now the obstacle is the current blockage of the location.</div>
<div class="codeline">[ This pulls data from a "current blockage" property of a room, specifically, the room the player's currently in. ]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Instead of Stevie Burns jumping: say "Even little Stevie hops over [the obstacle]." [ Jumping takes no parameters beyond the performing actor ]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Instead of Stevie Burns jumping <strong>over</strong> a fiery fallen beam: say "'Help!' says Stevie.</div>
<div class="codeline">You suddenly recall him telling you about the time his house burned down." [ We can now test on the local variable with an "over" phrase. ]</div>
</div>

<p>Because the <em>before</em>, <em>after</em>, and <em>instead</em>
rulebooks are shared among all actions, they may apply to entire
categories of actions. A named group of actions is called a <em>kind of
action</em>, and they have no special declaration syntax beyond the word
<em>is</em> sitting between the action's name and the kind-of-action's
name. This encourages all manner of nouns, adjectives, and adverbs to
name a kind-of-action, but some read better than others when used in
rule headers. In all cases, an action must be defined before attempting
to classify it.</p>

<div class="codeblock">
<div class="codeline">Whining is <strong>pointless behavior</strong>. [ "pointless behavior" is now a <em>kind of action</em> ]</div>
<div class="codeline">Temporarily waiting is <strong>pointless behavior<em>.</strong></em></div>
<div class="codeline">Discussing is <strong>conversation</strong>.</div>
<div class="codeline">Accusing it of is <strong>conversation</strong>.</div>
<div class="codeline">Accusing it of is <strong>drama</strong>.</div>
<div class="codeline">Teleporting to is <strong>drama</strong>.</div>
<div class="codeline">Tabulating is <strong>acting like a frickin' accountant</strong>.</div>
<div class="codeline">Scheduling is <strong>acting like a frickin' accountant</strong>.</div>
</div>

<p><em>Kinds of actions</em> can then be used in rule preambles. In the
following examples, remember than <em>when</em> and <em>during</em>
begin additional clauses that check global variables and whatnot.</p>

<div class="codeblock">
<div class="codeline">After <strong>pointless behavior</strong>: say "But you still feel unfulfilled.".</div>
<div class="codeline">Before <strong>conversation</strong> when the current interlocutor is not here, now the current interlocutor is a random person here.</div>
<div class="codeline">Instead of <strong>drama</strong>, say "(Now is the time to lay low!)".</div>
<div class="codeline">Instead of <strong>acting like a frickin' accountant</strong> during the collapsing bridge scene, say "You calculate (correctly) that you're about to become a victim of natural selection."</div>
</div>

<p>Any rulebook that can accept a kind-of-action can accept an explicit
list of actions as well. Let's then call that list Feature #1, because
of the many variations on it. There is a special kind-of-action, the
noun phrase <em>doing something/anything</em>, that matches all actions.
(Feature #2). Optionally, it may [#3] be followed by an <em>except</em>
or <em>other than</em> clause that lists actions. Then, optionally, we
may [4] tack on a set-description to further constrain the rule. (The
set-description can [5] be preceded with <em>with</em> or <em>to</em> if
we wish because it frequently improves readability.) And of course, we
may [6] always add other conditions with <em>when</em> and
<em>during</em>, such as the <em>in the presence of [person]</em>
boolean function.</p>

<div class="codeblock">
<div class="codeline">Before an actor discussing [4] a spiffy thing [6] when in the presence of Mr Blackheart: [...].</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Instead of [2] doing anything [3] except waiting [6] when the player is paralyzed, say "(Uhh... can't... move...)"</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Instead of someone [2] doing anything [3] except taking, dropping, or burning [5] with</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">[4] something incriminating, say "[The actor] says, 'No, I must get rid of [the noun]!'"</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">After [1] examining, looking under, or searching [4] anything owned by Mr Blackheart</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">[6] during a scene needing tension: say "Suddenly, Blackheart re-enters the room. 'What are you doing.' It wasn't a question."</div>
</div>

<p>Just to be clear, <em>doing something</em> is a single identifier.
<em>Doing</em> is not an action, and its following <em>something</em> is
not a set-description parameter. But <em>something</em> is a
set-description elsewhere, as in <em>examining something</em> or
<em>accusing something of something</em>.</p>

<p>There's six caveats to know.</p>

<p>
<ol class="num">
<li>When using <em>doing something</em>, we must remember that
<em>looking</em> is what primarily prints text when we enter a place &ndash;
or re-prints it when we load the game, etc. &ndash; so we frequently will
want to allow it.</li>
<li>When using <em>doing something to/with/-- something</em>, actions of
low arity like <em>sleeping</em> and <em>waiting</em> won't be caught by
it, because they never apply <em>to/with something</em>.</li>
<li>The docs don't cover any syntax for constraints on <em>the second
noun</em>, but a <em>when</em> clause can be appended.</li>
<li>When explicitly listing several actions together, they must
<em>check</em> the same arity. (So we can't combine <em>sleeping</em>
with <em>examining something</em>, but we can combine <em>sleeping</em>
and <em>examining</em>. The arity of the check, not of the action, is
important.)</li>
<li>But we <em>can</em> combine them using a <em>kind of action</em>
(see immediately below).</li>
<li>In all cases, the subject of the actions is kept completely separate
from the rest of the action-description. Consider it already processed
by the time the verb is reached.</li>
</ol>
</p>

<div class="codeblock">
<div class="codeline">Examining something is acting like a klutz. [ not "an actor examining something" ]</div>
<div class="codeline">Dropping someone is acting like a klutz. [ notice the "someone" ]</div>
<div class="codeline">Looking is acting like a klutz. [ arity of the check is lesser than the other two ]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Before someone acting like a klutz: [...]. [works for any NPC examining a Thing, dropping a Person, or Looking]</div>
</div>

<h2 id="understanding-our-player-our-parser">Understanding Our Player,
Our Parser</h2>
<p>The player's parser is a fairly simplistic one, little changed over a
decade of use, but it makes heavy use of callbacks for some surprising
extensibility. These parser callbacks are called topics (meaning, they
are of type Topic). Topics are simplistic regexes in the shape of a
boolean function, and if they match, they "return" what object, unit,
action, or value they find by setting global variables. A given topic
must "return" only one particular type; more on that in a moment. We use
Understand sentences to add these topics to the pre-existing list of
other topics that the parser runs down. Here are some examples of using
Understand to connect topics with actions:</p>

<div class="codeblock">
<div class="codeline"><strong>Understand</strong> "whine" <strong>as</strong> whining.</div>
<div class="codeline"><strong>Understand</strong> "donate [something]" <strong>as</strong> donating.</div>
<div class="codeline"><strong>Understand</strong> "give away [something]" <strong>as</strong> donating. [ We're making a synonym here. ]</div>
<div class="codeline"><strong>Understand</strong> "discuss [text]" or "talk about [text]" <strong>as</strong> discussing. [ Ditto, but as one topic not two. ]</div>
<div class="codeline"><strong>Understand</strong> "tabulate [a number]" <strong>as</strong> tabulating.</div>
<div class="codeline"><strong>Understand</strong> "answer [truth state]" <strong>as</strong> answering.</div>
<div class="codeline"><strong>Understand</strong> "schedule [a time]" <strong>as</strong> scheduling.</div>
<div class="codeline"><strong>Understand</strong> "wait for [a time period]" <strong>as</strong> temporarily waiting.</div>
<div class="codeline"><strong>Understand</strong> "teleport to/-- [any room]" <strong>as</strong> teleporting to. [ The altercation slash can't be used on the first word ]</div>
<div class="codeline"><strong>Understand</strong> "accuse [someone] of committing/-- [any thing]" <strong>as</strong> accusing it of.</div>
<div class="codeline"><strong>Understand</strong> "[any thing] committed by/via [someone]" <strong>as</strong> accusing it of <strong>(with nouns reversed)<em>.</strong></em></div>
<div class="codeline"><strong>Understand</strong> "wear [something preferably held]" <strong>as</strong> wearing.</div>
<div class="codeline"><strong>Understand</strong> "put [other things] in/inside/into [something]" <strong>as</strong> inserting it into.</div>
<div class="codeline"><strong>Understand</strong> "deposit [something] in/into [an open container]" <strong>as</strong> inserting it into.</div>
<div class="codeline"><strong>Understand</strong> "go to [any adjacent visited room]" <strong>as</strong> going by name.</div>
<div class="codeline"><strong>Understand</strong> "tattoo [limb] of [someone]" or "tattoo [specific limb] of [someone]" <strong>as</strong> tattooing it of.</div>
</div>

<p>The whole text between <em>understand</em> and <em>as</em> is a
topic, and the text in the square brackets is yet another topic called
by the larger topic. The called topics start their parsing where the
calling topic left off, trying to decide if the words that follow match
itself.</p>

<p>The topic <em>any thing</em> &ndash; as opposed to <em>thing</em> or <em>a
thing</em> or <em>something</em> &ndash; ignores the limitations of scope and
will match any valid object found in the whole game. The word
<em>any</em> in general works like this, and must be echoed in the
action definition by the word <em>visible</em>. Other topics are
intended for a particular type &ndash; <em>time, number,</em> a particular
<em>unit</em>, named values like <em>limb</em>, undigested <em>text</em>
which actions reference by <em>applying to one topic</em>, etc. We may
also use set-descriptions here: <em>an open container</em>, <em>any
adjacent visited room</em>, <em>something related by reversed
containment,</em> and so on.</p>

<p><em>Understand</em> can also expose other parts of our games to our
players: property adjectives, synonyms for object names, and even other
topics.</p>

<div class="codeblock">
<div class="codeline"><strong>Understand</strong> "dog" <strong>as</strong> Rover.</div>
<div class="codeline"><strong>Understand</strong> "birds" and "ruddy ducks" <strong>as the plural of</strong> duck.</div>
<div class="codeline"><strong>Understand</strong> "upper [limb]" or "lower [limb]" <strong>as</strong> "[specific limb]". [this won't capture the words Upper or Lower, but allows the player to use them ]</div>
<div class="codeline"><strong>Understand</strong> "beneath/under/by/near/beside/alongside/against" or "next to" or "in front of" <strong>as</strong> "[nearby]". [this is a convenience for the programmer only]</div>
</div>

<p>Any single topic can only return one specific type of something.</p>

<div class="codeblock">
<div class="codeline"><strong>Understand</strong> "colour [a colour]" or "[something]" <strong>as</strong> "[tint]". [ERROR: is this Topic's return type <em>color</em> or <em>thing</em>?]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">A pot is a kind of thing.</div>
<div class="codeline">A pot can be broken or unbroken.</div>
<div class="codeline"><strong>Understand</strong> the unbroken <strong>property as referring to</strong> the pot. [or, "...the broken property..."]</div>
<div class="codeline"><strong>Understand</strong> "shattered" or "cracked" or "smashed" <strong>as</strong> broken.</div>
<div class="codeline"><strong>Understand</strong> "pristine" <strong>as</strong> unbroken.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>Understand</strong> the broken <strong>property as describing</strong> a flowerpot. [describing disallows "take broken"; player must provide the noun: "taken broken pot"]</div>
</div>

<p>We can understand kinds (classes) which will at least narrow down the
player's possible referent.</p>

<div class="codeblock">
<div class="codeline"><strong>Understand</strong> "machine" <strong>as</strong> a device.</div>
<div class="codeline"><strong>Understand</strong> "bottle of [something related by containment]" <strong>as</strong> a bottle.</div>
</div>

<p><em>If</em> conditions can be attached to any <em>understand</em>
statement, so the parser will ignore the line if its condition isn't
met.</p>

<div class="codeblock">
<div class="codeline"><strong>Understand</strong> "rouge" <strong>as</strong> red <strong>when</strong> the make-up set is visible.</div>
<div class="codeline"><strong>Understand</strong> "Rover" <strong>as</strong> Rover The Dog <strong>when</strong> the player knows-about Rover.</div>
<div class="codeline"><strong>Understand</strong> "your" <strong>as</strong> a thing <strong>when</strong> the person asked has the item described.</div>
</div>

<p>But remember that this happens during parsing of the player's
command, so the condition can't always refer to information within the
command itself, such as <em>the noun</em> or <em>the second noun</em>.
In the case of <em>the person asked</em>, it works for FRODO, GIVE ME
YOUR RING because Frodo has been parsed already, but will likely fail if
"your" is the first word of the command.</p>

<p>If we just want a simple reply with no processing, there's a
shorthand.</p>

<div class="codeblock">
<div class="codeline"><strong>Understand</strong> "xyzzy" <strong>as a mistake ("</strong>Ah, I see you're an old hand at this.<strong>")</strong>.</div>
<div class="codeline"><strong>Understand</strong> "xyzzy" <strong>as a mistake ("</strong>The machine doesn't seem to have a button with that label on it.<strong>") when</strong> in the teleportation chamber.</div>
</div>

<p>Mistakes can use the <em>[text]</em> token but little else. They can
use <em>say-phrases</em> in what they print, so it is possible to do
some simple codework from them. Mistake lines are parsed before
non-mistake lines, because they're intended to cover exceptions to
grammar or one-off, out-of-game remarks by the player, rather than
entire categories of input.</p>

<p>Finally, a distinction in the <em>time</em> type that understand
makes but the rest of the compiler does not. The <em>time</em> datatype
comes in two flavors, instants and durations. Three and a half hours
would be a duration, while 3:30 pm is an instant, a specific point on
the timeline. Internally, both are stored as the number of elapsed
minutes since 4 am, but actions need to know which flavor the player
types in. So, only <em>understand</em> assertions distinguish between,
<em>[time],</em> an instant, and <em>[time period],</em> a duration.
Math is straightforward once after parsing: adding or subtracting a
duration produces whichever it's being combined with, while subtracting
two instants produces a duration. But adding two instants is nonsense:
what could 9:38 pm plus 4:47 am possibly be?</p>

<div class="codeblock">
<div class="codeline">Understand "wait until [<strong>a time</strong>]" as waiting until. [ wait until a moment, such as <em>1 pm</em> ]</div>
<div class="codeline">Understand "wait for [<strong>a time period</strong>]" as waiting for. [ wait for a duration, such as <em>an hour</em> ]</div>
</div>

<h2 id="arrays-have-been-tabled">Arrays Have Been Tabled</h2>
<p>Inform is not a language of computation. It is a language designed to
hold secrets for the player to discover. So its two-dimensional arrays
&ndash; tables &ndash; are primarily intended for a single, occasional lookup.
Tables are statically-allocated like everything else, and the words
"row" and "column" are used in lieu of (x,y) coordinates.</p>

<p>Here's an example table from the docs:</p>

<div class="codeblock">
<div class="codeline"><strong>Table 2.1 - Selected Elements</strong></div>
<table>
<tbody>
<tr class="even">
<td style="text-align: left;">Element (some text)</td>
<td style="text-align: left;">Symbol (some text)</td>
<td style="text-align: left;">Atomic number (a number)</td>
<td style="text-align: left;">Atomic weight (a number)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">"Hydrogen"</td>
<td style="text-align: left;">"H"</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">"Iron"</td>
<td style="text-align: left;">"Fe"</td>
<td style="text-align: left;">26</td>
<td style="text-align: left;">56</td>
</tr>
<tr class="odd">
<td style="text-align: left;">"Zinc"</td>
<td style="text-align: left;">"Zn"</td>
<td style="text-align: left;">30</td>
<td style="text-align: left;">65</td>
</tr>
<tr class="even">
<td style="text-align: left;">"Uranium"</td>
<td style="text-align: left;">"U"</td>
<td style="text-align: left;">92</td>
<td style="text-align: left;">238</td>
</tr>
</tbody>
</table>
</div>

<p>Or, alternately:</p>

<div class="codeblock">
<div class="codeline"><strong>Table of Selected Elements</strong></div>
<table>
<tbody>
<tr class="even">
<td style="text-align: left;">Element</td>
<td style="text-align: left;">Symbol</td>
<td style="text-align: left;">Atomic number</td>
<td style="text-align: left;">Atomic weight</td>
</tr>
<tr class="odd">
<td style="text-align: left;">text</td>
<td style="text-align: left;">text</td>
<td style="text-align: left;">number</td>
<td style="text-align: left;">number</td>
</tr>
<tr class="even">
<td style="text-align: left;">"Hydrogen"</td>
<td style="text-align: left;">"H"</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">"Iron"</td>
<td style="text-align: left;">"Fe"</td>
<td style="text-align: left;">26</td>
<td style="text-align: left;">56</td>
</tr>
</tbody>
</table>
</div>

<p>A blank line and the keyword <em>table</em> begin the whole affair.
At least one tab character is required to end a column and start the
next. Multiple tabs and spaces are OK. The first tab character Inform
comes across melds together all whitespace surrounding it. Type
information can either be left off &ndash; Inform will deduce it mostly
correctly &ndash; or can be given in the two styles shown. Both styles have
problems. The first, "inline" style only allows <em>object</em> for
objects, not a particular class. The in-row style allows specific class
names, but introduces a bug &ndash; row #1 will be a blank row that doesn't
correctly flag itself as blank. This is because we can leave individual
entries blank, which would need the type explicitly stated.</p>

<div class="codeblock">
<div class="codeline"><strong>Table of Energy Proponents</strong></div>
<table>
<tbody>
<tr class="even">
<td style="text-align: left;">Proponent</td>
<td style="text-align: left;">Fuel</td>
<td style="text-align: left;">Danger</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Bob</td>
<td style="text-align: left;">Hydrogen</td>
<td style="text-align: left;">a number</td>
</tr>
<tr class="even">
<td style="text-align: left;">Phoebe</td>
<td style="text-align: left;">Wind</td>
<td style="text-align: left;">--</td>
</tr>
<tr class="odd">
<td style="text-align: left;">--</td>
<td style="text-align: left;">Geothermal</td>
<td style="text-align: left;">--</td>
</tr>
<tr class="even">
<td style="text-align: left;">Jean</td>
<td style="text-align: left;">Nuclear</td>
<td style="text-align: left;">10</td>
</tr>
</tbody>
</table>
<div class="codeline">with 4 blank rows.</div>
</div>

<p>A blank entry is denoted by the -- double-dash. The last line
(<em>with X blank rows</em>) statically allocates some extra space. A
character's responses to the player's inquiries on various topics has
special syntax, a column entitled <em>topic</em> whose type will also be
<em>topic</em>. Remember that topics are simple regexes, so they cannot
be printed.</p>

<div class="codeblock">
<div class="codeline"><strong>Table of NPC Responses</strong></div>
<table>
<tbody>
<tr class="even">
<td style="text-align: left;">topic</td>
<td style="text-align: left;">answer</td>
</tr>
<tr class="odd">
<td style="text-align: left;">"hi/hello"</td>
<td style="text-align: left;">"He says, 'Well hello there!'"</td>
</tr>
<tr class="even">
<td style="text-align: left;">"bye/goodbye"</td>
<td style="text-align: left;">"'Take care,' he answers."</td>
</tr>
</tbody>
</table>
</div>

<p>There's several phrases to work with tables, but it's still one of
the more cumbersome parts of the language. This is because we must
<em>choose</em> a particular row to work with each <em>(column name)
entry</em> as if they were each a standalone variable. We can't pass a
chosen row to another function. We can't choose two rows simultaneously,
either in the same table or in different tables. We can't copy rows to
other rows. Finally, we can't create N-dimensional arrays except by
creating a column of type <em>table name</em> and the creation of a lot
of statically-allocated sub-tables by hand!</p>

<p>But knowing this, the phrases used for tables is fairly
self-explanatory. The following are all imperative procedures.</p>

<div class="codeblock">
<div class="codeline"><strong>blank out</strong> (table entry);</div>
<div class="codeline"><strong>blank out the whole row;</strong></div>
<div class="codeline"><strong>blank out the whole</strong> (column) <strong>of</strong> (table);</div>
<div class="codeline"><strong>blank out the whole of</strong> (table);</div>
<div class="codeline"><strong>if</strong> (value) <strong>is</strong> (a column) <strong>listed in</strong> (table),</div>
<div class="codeline"><strong>if there is no</strong> (column) <strong>entry,<em></strong></em></div>
<div class="codeline"><strong>if there is</strong> (a column) <strong>corresponding to</strong> (a column) <strong>of</strong> (value) <strong>in</strong> (table),</div>
<div class="codeline"><strong>if there is</strong> (a column) <strong>in row</strong> (number) <strong>of</strong> (table),</div>
<div class="codeline"><strong>choose a blank row in</strong> (table);</div>
<div class="codeline"><strong>choose row</strong> (number) <strong>in</strong> (table);</div>
<div class="codeline"><strong>choose row with</strong> (a column) <strong>of</strong> (value) <strong>in</strong> (table);</div>
<div class="codeline"><strong>sort</strong> (table) <strong>in</strong> <em>reverse</em> (column) <strong>order</strong>;</div>
<div class="codeline"><strong>sort</strong> (table) <strong>in random order;</strong></div>
</div>

<p>These are functions.</p>

<div class="codeblock">
<div class="codeline">the <strong>number of blank rows in</strong> (table)</div>
<div class="codeline">the <strong>number of filled rows in</strong> (table)</div>
<div class="codeline">the (column) <strong>corresponding to</strong> (a column) <strong>of</strong> (value) <strong>in</strong> (table)</div>
<div class="codeline">the (column) <strong>in row</strong> (number) <strong>of</strong> (table)</div>
</div>

<p>And these are used in rule preambles, working somewhat like a
set-description. Tables and topics are used together a lot, because it
frequently happens a character has a whole array of things to say in
response to various subjects. And the default types of the <em>asking it
about</em> action are <em>person</em> and <em>topic</em>,
respectively.</p>

<div class="codeblock">
<div class="codeline">After taking (a column) <strong>listed in</strong> (table): [...]</div>
<div class="codeline">After asking someone about <strong>a topic listed in</strong> (table): [...]</div>
</div>

<p>One concession to ease of use is that its sort routine is stable.
Meaning, if multiple rows have the same value in the column we sort on,
then their order vis-a-vis each other will not change.</p>

<p>A couple of features were added later to ease how tables and
extensions interact. First is the <em>(continued)</em> parenthetical. If
an extension creates a table, a game can append extra rows to it. Note
that the order is important &ndash; a table section with <em>(continued)</em>
must follow the table section without.</p>

<div class="codeblock">
<div class="codeline"><strong>Table of NPC Responses (continued)</strong></div>
<table>
<tbody>
<tr class="even">
<td style="text-align: left;">topic</td>
<td style="text-align: left;">answer</td>
</tr>
<tr class="odd">
<td style="text-align: left;">"thank/thanks you/--"</td>
<td style="text-align: left;">"'You're very welcome.'"</td>
</tr>
</tbody>
</table>
</div>

<p>The other feature is <em>(amended)</em> which allows the game to
replace the pre-existing rows in an extension's table. Again, the
amended section must come after the original, so order is important.
Inform knows which rows are and aren't amended by looking at the
left-most column(s) and matching them up. Generally, only simple values
can be matched in this way. So the ordering of our columns actually
matters as well, to the extension writer.</p>

<div class="codeblock">
<div class="codeline"><strong>Table of NPC Responses (amended)</strong></div>
<table>
<tbody>
<tr class="even">
<td style="text-align: left;">topic</td>
<td style="text-align: left;">answer</td>
</tr>
<tr class="odd">
<td style="text-align: left;">"hi/hello"</td>
<td style="text-align: left;">"He says, 'Whaddaya want?'"</td>
</tr>
</tbody>
</table>
</div>

<p>Finally, when we use generic types, a <em>K valued table column</em>
is the type of a typed column, mimicking <em>K valued property</em>.</p>

<h2 id="time-for-a-scene">Time for a Scene</h2>
<p>The <em>room</em> class divides space into discrete places.
<em>Scenes</em> divide an interactive fiction into durations of time.
Each scene is implemented as a boolean variable that is automatically
set and cleared by an asserted condition. Scenes happen only once,
unless declared as <em>recurring</em>.</p>

<div class="codeblock">
<div class="codeline">A lightsaber duel <strong>is a scene<em>.</strong></em></div>
<div class="codeline">&thinsp;</div>
<div class="codeline">A lightsaber duel <strong>begins when</strong> the location of Luke is the location of Darth.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">A lightsaber duel <strong>ends when</strong> Luke is too injured to continue or Darth is too injured to continue.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">A person can be too injured to continue.</div>
<div class="codeline">A person is rarely too injured to continue.</div>
</div>

<p>Rule headers and imperative code both can check to see if a scene is
happening.</p>

<div class="codeblock">
<div class="codeline">Every turn <strong>during</strong> a lightsaber duel, say "BWWAAUUAAAHH".</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">[...];</div>
<div class="codeline">if a lightsaber duel <strong>is happening,</strong> [...]</div>
</div>

<p>Each scene provides two rules that execute when the scene begins and
ends. These are just hooks we may use or ignore.</p>

<div class="codeblock">
<div class="codeline"><strong>When</strong> a lightsaber duel <strong>begins:</strong> now the command prompt is the battle command prompt.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>When</strong> a lightsaber duel <strong>ends:</strong> now the command prompt is the normal command prompt.</div>
</div>

<p>Scenes are not objects, but may still have properties. Text floating
out by itself after a scene definition goes into its
<em>description</em> property, which is automatically printed when the
scene begins.</p>

<div class="codeblock">
<div class="codeline">The train leaves is a scene. "All aboard!"</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">A scene <strong>can be</strong> dramatic or dull.</div>
<div class="codeline">The train leaves is dramatic.</div>
<div class="codeline">A scene <strong>has</strong> a person <strong>called</strong> its viewpoint character.</div>
</div>

<p>We can write set-descriptions about scenes as well.</p>

<div class="codeblock">
<div class="codeline">Every turn during <strong>a dull scene</strong>: [...].</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">[...];</div>
<div class="codeline">if <strong>a thrilling scene</strong> is happening, [...]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">When <strong>a thrilling scene</strong> begins: [...].</div>
</div>

<p>We can ask at what time, or how long ago, a scene began or ended with
<em>the time since (scene) began, the time since (scene) ended, the time
when (scene) began,</em> and <em>the time when (scene) ended.</em>
Extensions provide further phrases.</p>

<p>Implementation-wise, scenes are just an example of named values,
which follow. But because this is interactive fiction, scenes receive
more syntax support from the language, as they should.</p>

<div class="codeblock">
<div class="codeline">When the denouement ends, end the story finally.</div>
</div>

<h2 id="named-values-everywhere">Named Values Everywhere</h2>
<p>Named values are a type, similar to <em>time</em> or <em>number</em>
but finite in the number of instances. Inform uses named values
everywhere. Scenes, rulebook outcomes, even a boolean object property is
a named value of two values. We explicitly create new named values as a
<em>kind of value.</em></p>

<div class="codeblock">
<div class="codeline">A limb <strong>is a kind of value<em>.</strong></em></div>
<div class="codeline">The <em>limbs</em> <strong>are</strong> left leg, left arm, right leg, right arm, the neck, and the back.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">A tattoo <strong>is a kind of value<em>.</strong></em></div>
<div class="codeline">Some <em>tattoos</em> <strong>are</strong> mom, barbed wire, wings, a kanji, a pseudo-photograph, and some obscure symbol.</div>
<div class="codeline">Some <em>tattoos</em> <strong>are</strong> celtic knotwork and a tribal something-or-other.</div>
</div>

<p>Named values can have spaces in their names, but they cannot have
their names abbreviated like objects can. Inform generally allows almost
any word to be part of a named value, but be warned, if you put words
like "when" or "is" in a named value, it may create compilation problems
when used in other places. The articles used in defining a <em>kind of
value</em> are usually ignored, but it is good practice to ensure both
the singular (<em>a tattoo</em>) and plural (<em>some tattoos</em>)
versions of the <em>kind of value</em> are used in order to prevent
mystifying compiler errors later on. Finally, not all of a named value's
names need be defined in a single sentence.</p>

<p>Named values can be used almost anywhere an object can. Plus there's
a few phrases with named values can used but objects can't, since
multiple object instances don't have any sort of ordering to them. In
the following, the action <em>tattooing</em>, the relation <em>is/are
tattooed with</em>, and the named value <em>tattoos</em> are all
distinct from one another.</p>

<div class="codeblock">
<div class="codeline">now the offended body part is <strong>the limb after</strong> <em>the left leg</em>;</div>
<div class="codeline">now the offended body part is <strong>the limb before</strong> <em>the back</em>;</div>
<div class="codeline">now the offended body part is <strong>the first value of</strong> <em>limb</em>;</div>
<div class="codeline">now the offended body part is <strong>the last value of</strong> <em>limb</em>;</div>
<div class="codeline">now the drawn tattoo is <strong>a random</strong> <em>tattoo</em> <strong>between</strong> <em>wings</em> <strong>and</strong> <em>celtic knotwork</em>.</div>
<div class="codeline"><strong>Definition:</strong> a <em>limb</em> is hurt if [...].</div>
<div class="codeline">Tattooing is <strong>an action applying to</strong> one <em>limb</em> and one thing.</div>
<div class="codeline"><strong>Understand</strong> "tattoo [<em>limb</em>] of [someone]" <strong>as</strong> tattooing.</div>
<div class="codeline">Exposition <strong>relates</strong> various people <strong>to</strong> various <em>tattoos</em>.</div>
<div class="codeline">The verb to be tattooed with implies the exposition relation.</div>
<div class="codeline">Joan is tattooed with <em>some obscure symbol</em>.</div>
<div class="codeline"><strong>repeat with</strong> place <strong>running through</strong> each <em>limb</em>: [...]</div>
<div class="codeline">A <em>tattoo</em> <strong>can be</strong> sleeved, stamped, or hidden.</div>
<div class="codeline"><em>Kanji</em> are <em>hidden</em>.</div>
<div class="codeline">A <em>tattoo</em> <strong>has</strong> a <em>topic</em> <strong>called</strong> the conversation starter.</div>
</div>

<p>Tables can defined a slew of named values. If used with the above,
this method of definition must come first.</p>

<div class="codeblock">
<div class="codeline">Tattoos are a kind of value.</div>
<div class="codeline">Some tattoos <strong>are defined by</strong> <em>the table of designs</em>.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>Table of Designs</strong></div>
<table>
<tbody>
<tr class="even">
<td style="text-align: left;"><em>tattoo</em></td>
<td style="text-align: left;"><em>topic</em></td>
</tr>
<tr class="odd">
<td style="text-align: left;">barbed wire</td>
<td style="text-align: left;">"barbed/wire/tattoo"</td>
</tr>
<tr class="even">
<td style="text-align: left;">wings</td>
<td style="text-align: left;">"nice/angel/pretty"</td>
</tr>
</tbody>
</table>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>Table of Designs (continued)</strong></div>
<table>
<tbody>
<tr class="even">
<td style="text-align: left;"><em>tattoo</em></td>
<td style="text-align: left;"><em>topic</em></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Jean-Pierre 4-ever</td>
<td style="text-align: left;">"who/was/jean/pierre"</td>
</tr>
</tbody>
</table>
</div>

<p>Inform automatically creates some named values that correspond to
other parts of the language. For example, <em>the containment
relation</em> is an example of the relations named value, which
corresponds to a built-in relation. This named value is passed into
phrases such as the pathfinding and lookup functions mentioned in the
relations chapter. New relations would be treated similarly: <em>the
teenage love relation</em>. Likewise, <em>action name</em> is the named
value counterparts for actions: <em>the looking action</em>, <em>the
inserting it into action</em>, etc. Other times, one part of the
language is little more than a named value.</p>

<h2 id="its-not-just-text">It's Not Just Text</h2>
<p>Though it's probably obvious by now, text goes between double quotes.
Within it, square brackets denote a <em>say-phrase</em> (procedure
call). Inform's print command is <em>say,</em> and it expands to a
series of print statements and function calls in the generated Inform 6.
As a nod toward the world of the printed word, a double quote within a
string is written as an apostrophe, and the apostrophe itself is the
say-phrase [']. The say-phrase isn't needed in common words like don't
or can't. As a convenience feature, a string ending in a period,
question mark, or exclamation mark has an automatic line break appended.
An extra space nullifies this behavior. So, in order to print:</p>


<blockquote><p>Rene Descartes said, "I think not!" and promptly disappeared.<br> So
don't ever say that, 'k?</p></blockquote>

<p>&hellip; we use:</p>

<div class="codeblock">
<div class="codeline">say "Rene Descartes said, 'I think not!' and promptly disappeared.<strong>[line break]</strong>So don't ever say that, <strong>[']</strong>k?";</div>
</div>

<p>Variables and objects in square brackets say their value or
<em>printed name</em>, respectively. (The latter invokes the
<em>printing the name</em> activity we'll soon see.) Other useful text
properties are the <em>initial appearance</em> property, usually printed
by the <em>looking</em> action, and the <em>description</em> property,
which is usually printed by the <em>examining</em> action when it's on
objects, or by the <em>when (scene) begins</em> rule for scenes. Some
useful global text variables are <em>the command prompt</em>, which is
usually the &gt; greater-than symbol, <em>the left hand status
line</em>, which is usually the name of the player's location, and
<em>the right hand status line</em>, which typically holds the score.
Communicating with the outside world are <em>the story title</em>,
<em>the story author</em>, <em>the story headline</em>, <em>the story
genre,</em> and <em>the story description,</em> which collectively
create the "library card" used by websites like IFDB and in the game's
own <em>banner text</em> seen at game start.</p>

<p>Preview the library card in the contents tab of the index.</p>

<p>Inform was originally designed to make games with a very small memory
footprint, so a game's output text is compressed and language support
for regexes is poor. The <em>text</em> type is this compressed text.
<em>Indexed text</em> is a later and still optional addition to the
language.</p>

<p>Regexes operate only on the latter but can implicitly typecast the
former. Both types use double quotes identically, so constructions like
the following are needed to avoid creating plain <em>text</em>.</p>

<div class="codeblock">
<div class="codeline">let T be indexed text;</div>
<div class="codeline">let T be "Hello World";</div>
</div>

<p>Manipulating the player's inputted text is mediated through
<em>snippets</em>, <em>topics</em>, and the phrases <em>if (snippet)
includes (topic), if (snippet) matches (topic),</em> the <em>does
not</em> negated versions, <em>cut (snippet),</em> and <em>replace
(snippet) with (text)</em>. A <em>snippet</em> is a pair of numbers,
joined together like fixed-point notation, that represent a range of
words. "The 3 words starting at word #2" would be the snippet 203. There
are only three built-in <em>snippet</em> variables: <em>the player's
command</em>, <em>the matched text</em>, and the deviously-named <em>the
topic understood</em> which is used in actions <em>applying to one
topic</em>.</p>

<div class="codeblock">
<div class="codeline">After reading a command:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;if <em>the player's command</em> <strong>does not include</strong> <em>"please/thanks"</em>, say "How rude!" instead;</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;if <em>the player's command</em> <strong>includes</strong> <em>"please/thanks"</em>, <strong>cut</strong> <em>the matched text</em>;</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;if <em>the player's command</em> <strong>matches</strong> <em>"hi there"</em>, <strong>replace</strong> <em>the matched text</em> <strong>with</strong> "hello";</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Report asking Bob about <em>"home/leaving"</em>:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "Bob rambles on about how only slackers think of [<em>the topic understood</em>] so much." instead.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Understand <em>"bastard", "rat/prissy bastard", or "sir"</em> as Bob.</div>
</div>

<p><em>Topics</em> are regexes from a time when the term "regular
expressions" was still mathematically correct. They are written within
double-quotes and depend upon the invoking phrase to infer the type.
Their only operator is "or", indicated by the / forward slash, or, in
<em>understand</em> lines, by commas and conjunctions when outside
quotes. Topics are frequently used in a game's conversation system
because many subjects aren't physical objects which most standard
actions need manipulate, and regexes require less memory than objects.
(Incidentally, this is also why the object hierarchy lacks an
<em>idea</em> or <em>concept</em> class.)</p>

<p>Indexed text is troublesome because Inform tries to remain
statically-allocated, but the full Perl-like regex system works on it.
Typecast between snippets and indexed text like so.</p>

<div class="codeblock">
<div class="codeline"><strong>let</strong> the command-to-be <strong>be</strong> <em>indexed text</em>;</div>
<div class="codeline"><strong>let</strong> the command-to-be <strong>be</strong> the player's command;</div>
<div class="codeline">[...];</div>
<div class="codeline"><strong>change the text of the player's command to</strong> the command-to-be; [ this is a special-case syntax ]</div>
</div>

<h2 id="precisely-one-spoon-unit-of-sugar">Precisely One Spoon-unit of
Sugar</h2>
<p>Units are user-defined numeric types with some nifty syntactic sugar,
sugar that extends even to our player. Generally in programming, numbers
are numbers: the programmer must remember one variable measures in
pixels while another measures in picos, and to mix the two makes bad
medicine. But Inform allows us to define unique ways of writing the
numbers &ndash; by wrapping identifiers and punctuation marks (the
"preamble") around them. The individual numbers ("parts") in the
construction can be given names for later referencing.</p>

<div class="codeblock">
<div class="codeline">Money is a kind of value.</div>
<div class="codeline">$19.99 specifies some money with parts dollars (without leading zeros) and cents (optional, preamble optional).</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">My wallet is some money that varies.</div>
<div class="codeline">My wallet is usually $20.75.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">A thing has some money called the price.</div>
<div class="codeline">The price of a thing is usually $5.</div>
<div class="codeline">The price of Bob is $2.05.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">say "[the dollars part of the price of Bob]";</div>
</div>

<p>We can only add and subtract units, assuming the units match. To
allow multiplication and division, we can specify what new unit is
created. Note the re-use of the specify/specifies verb.</p>

<div class="codeblock">
<div class="codeline">A length is a kind of value. 10 m specifies a length. An area is a kind of value. 10 sq m specifies an area. A length times a length specifies an area.</div>
</div>

<p>We can always multiply and divide a unit by a plain number.
Multiplying and dividing by one is how we explicitly typecast between
units and numbers. We can also define units that are scaled versions of
each other. Inform doesn't support floating point, but it can combine
the types into a fixed-point type this way.</p>

<div class="codeblock">
<div class="codeline">1m specifies a length.</div>
<div class="codeline">1cm specifies a length scaled down by 100.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">1m specifies a length scaled at 100. [ This has similar effect without defining cm. ]</div>
</div>

<p>Inform automatically creates a new Understand token from units. The
player writes the unit the same way we do.</p>

<div class="codeblock">
<div class="codeline">Understand "donate [money]" as donating. </div>
<div class="codeline">Donating is an action applying to some money.</div>
</div>

<p>Finally, we can re-use the <em>implies</em> statement from defining
relations for an extra dose of sugar.</p>

<div class="codeblock">
<div class="codeline">The verb to cost (it costs, they cost, it is costing) implies the price property.</div>
<div class="codeline">The jeans cost $19.95.</div>
</div>

<p>Note that we didn't define a relation there, though it may look like
it. But we could:</p>

<div class="codeblock">
<div class="codeline">Fanciness relates a thing (called X) to some money (called Y) when the price of X > Y.</div>
<div class="codeline">The verb to be fancier than implies the fanciness relation.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">let L be the list of things fancier than $2.50;</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">let B be the list of things fancier than the price of jeans;</div>
</div>

<p>The built-in type <em>time</em> is not a unit, but pretends to be.
Time's parts &ndash; hours and minutes &ndash; are calculated from a 4 AM
minute-count, not stored as separate numbers as units are done.</p>

<p>Inform also supports dimensional analysis on units when used in
<em>equations</em>. Mathematics is the ultimate declarative language: it
needn't compile to assembly. So Inform sets off its declarative
equations from the normal flow of code and prose. Variables are one to
ten letters long, and may be set right next to each other to represent
multiplication. Whitespace is insignificant. The types of the variables
are listed afterward in a <em>where</em> line, always number or a
particular unit, and possibly a global variable or exact value.</p>

<div class="codeblock">
  <div class="codeline">Equation - Volume of a Cylinder</div>
  <div class="codeline">V=pir^2h</div>
<div class="codeline">where V is a number, pi is 3, r is the radius, h is a number. The radius is a number that varies.</div>
</div>

<p>The local variables can appear outside the equation, especially when
we use the equation to find that value.</p>

<div class="codeblock">
<div class="codeline">let h be 15;</div>
<div class="codeline">let V be given by the volume of a cylinder, where r is 5;</div>
</div>

<p>The values for all variables except one must be suppled by the time
<em>given by</em> is invoked. There's four ways to supply a value. One
is as a constant, as we've done with <em>pi</em>. Two is by global
variable, as we've intended with <em>radius</em>. (Note the compiler
won't ensure we've initialized the global.) Three is by declaring and
initializing the variable with <em>let</em> like any local variable, as
we've done with <em>h</em>. And finally is the <em>where</em> line
itself, as we've done with radius (<em>where r is 5</em>) and overridden
the global. The answer will either go into the local we declare with
<em>given by</em>, as we've done with <em>V</em>, or into the global it
is tied to, such as the following which populates the global
<em>radius</em> but leaves <em>r</em> undefined.</p>

<div class="codeblock">
<div class="codeline">let r be given by the volume of a cylinder, where V is 25, and h is 2;</div>
</div>

<p>Note that the above knew to use the square root to find the radius,
but we cannot specify the square root in the equation ourselves. Besides
parentheses, equations support addition, subtraction, multiplication,
division, and exponentiation directly, and for squares and cubes, can
rearrange terms to take the square root or cube root as appropriate. But
we cannot specify roots in equations ourselves, so we would have to code
the quadratic equation traditionally.</p>

<p>Even with those constraints, there are many equations that Inform
cannot rearrange. Polynomials are a fine example. And all math here is
integer &ndash; Inform does not currently support floating point. (Fixed
point is supported, but only as part of a <em>scaled</em> unit.) The
equations feature is not intended as a mathematical tool, but as a
coding feature for convenience and correctness. If we need to solve for
multiple different variables from the same formula, it is better coding
practice to write the formula once as an equation than to write multiple
<em>to-decide</em> functions, one per variable.</p>

<p>Units have difficulty with aggregates such coordinates. For example,
the following formula is defined using all numbers, because even though
the types of <em>x</em> and <em>y</em> are different, and <em>y</em> and
<em>b</em> are the same, Inform's dimensional analysis will not allow
them to be combined.</p>

<div class="codeblock">
  <div class="codeline">Equation - Slope-Intercept Formula</div>
  <div class="codeline">y = mx + b</div>
<div class="codeline">where y is a number, x is a number, m is a number, and b is a number.</div>
</div>

<h2 id="backstage-activities">Backstage Activities</h2>
<p>Actions are player-generated events. Activities are library-generated
events. Typically they print something that an author might want to
customize for their work. Parsing, prose generation, complex actions,
and a few miscellaneous events to bookend the game comprise the bulk of
activities. It's interesting that what events a library exposes is
indicative of what the tool considers, and has considered, important
over the years.</p>

<p>Each activity is composed of three rulebooks, whose names begin with
<em>before</em>, <em>for</em>, and <em>after</em>. The default outcome
of the <em>for</em> rulebooks is success, so only the most specific
applicable rule will fire. The other two run all applicable rules within
themselves. We can test to see if an activity in progress via
<em>while</em> in the rule preamble. This allows us to vary narration of
the same object or event differently depending on context.</p>

<p>The optional word <em>rule</em> may begin a <em>for</em> rule as
syntactic sugar, and the usual <em>of, for, rule</em> may be inserted
before the parameter. For activities with have articles in their name,
such as <em>printing the name</em>, those articles are required. An
activity's name allows no leeway in its wording.</p>

<p>Explanations of each activity, and its general category, follow.</p>

<p><h3 id="activities-prose-generation">Prose Generation.</h3> This may be a heavy label for what
is essentially just outputting the contents of text properties, but they
are some of the most important library events in Inform. The current
contents of these rulebooks in a given work are listed in the "How
Things are Described" section within the Rules tab of the Index.</p>

<p><em>Printing the name of something.</em> This prints the printed name
property. As many times per turn as this activity is called, it's more
efficient to put say-phrases in the <em>printed name</em> property than
create a rule that runs when every other object's name needs be printed.
Still, to change the name for a set-description, or for unusually
complicated situations, it is still one of the most used activities in
Inform.</p>

<div class="codeblock">
<div class="codeline">Rule <strong>for printing the name</strong> of Joan when Joan has not managed the player: say "important-looking woman".</div>
</div>

<p><em>Printing the plural name of something.</em> This prints the
<em>printed plural name</em> property. This is only used from within the
following <em>printing a number</em> activity, right after said number
is printed.</p>

<p><em>Printing a number of something.</em> Used for indistinguishable
instances of a class, because a list of "a coin, a coin, a coin" is
pretty dull, and normal instances each have a distinct name of their
own. Skipped if there's only one such in the location. The variable
<em>listing group size</em> holds the number, and is useful with the
say-phrase in words. Calls the above <em>printing the plural name</em>
activity.</p>

<p><em>Listing contents of something.</em> This very useful library
event pretty-prints a list of objects contained within the sole object
passed to it, such as the player or the location. It's used by
<em>taking inventory</em> and for the you-can-also-see sentence of
<em>looking</em>. Its before rules provide the phrases <em>group
(set-description) together</em>, <em>group (set-description) together as
(text)</em>, and <em>group (set-description) together giving
articles</em>, which ensures a multitude of instances appear next to one
another in the list by calling the following activity grouping
together.</p>

<p><em>Grouping together something.</em> Utilized by the above to wrap
or replace the members of the group with other text. A <em>for</em> rule
here will override the text used in <em>group (description) together as
(text)</em>, and is a good way to treat multiple distinct instances as
if they were indistinguishable instances (such as our coins example).
The variable <em>listing group size</em> again holds the number of group
members. The passed-in parameter is only the first member of the group,
and is otherwise insignificant.</p>

<p>(The multiple activities belonging to <em>looking</em> are in their
own section further down.)</p>

<p><h3 id="activities-parsing-input">Parsing Input.</h3> Doing a good job with these
activities can make or break a game. The contents of all these rulebooks
are listed in the "How Commands are Understood" section of the Rules tab
of the Index.</p>

<p><em>Printing a parser error.</em> A distressingly important activity,
it allows narration of the nineteen different parser errors Inform can
throw, none of which are terribly informative for how the player should
re-factor his input. While extensions such as Default Messages and
Custom Library Messages can change the parser errors themselves,
typically it is useful to vary the errors based on situation and
available information, to give the player much better, much more
specific feedback.</p>

<p><em>For printing a parser error</em> when the latest parser error is
<em>I beg your pardon</em>: try looking.</p>

<p><em>Reading a command.</em> Each of the three phases of this activity
is useful. <em>Before</em> is useful for initializing variables for the
next turn. <em>For</em> rules can actually skip reading the player's
command, allowing us to insert text into the command buffer directly and
use that instead, via the special-case phrase <em>change the text of the
player's command to (indexed text)</em>. <em>After</em> rules are useful
for massaging the input before it is fed to the parser. Note that
although Inform supports regexes, they are slow, so use the following
standard phrases if at all possible. The forward slash denotes
high-precedence altercation.</p>

<div class="codeblock">
<div class="codeline"><strong>After reading a command</strong> when the player's command includes "please/thanks", cut the matched text.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>After reading a command</strong> when the player's command matches "take a nap", replace the matched text with "nap".</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>For reading a command</strong> when the command to retry is not "":</div>
<div class="codeline">&nbsp;&nbsp;<strong>change the text of the player's command to</strong> the command to retry;</div>
<div class="codeline">&nbsp;&nbsp;now the command to retry is "".</div>
</div>

<p><em>Clarifying the parser's choice of something.</em> When the parser
takes a guess at what the player meant (via the <em>does the player
mean</em> rulebook), it says so in a parenthetical like, "(your coat)".
We can change this message, or for bleedingly obvious cases, censor it.
The variable <em>the item described</em> refers to the parameter.</p>

<div class="codeblock">
<div class="codeline"><em>For clarifying the parser's choice</em> of your coat: do nothing.</div>
</div>

<p><em>Asking which do you mean.</em> When the parser cannot guess which
object was meant, usually because the name the player used applies
equally to either one and <em>does the player mean</em> was no help, it
ask, "Which X did you mean?" Though writing a <em>for</em> rule would be
a major undertaking, it's use may be in <em>printing the name</em> as a
condition, <em>while asking which do you mean</em>.</p>

<p><em>Supplying a missing noun.</em> Sometimes a verb is used without a
noun because the noun is obvious in some way. For example, EAT when
there's only one edible thing in the location. By informing the grammar
rules that a verb can be entered without the noun, this activity will be
called to assign something to <em>the noun</em>. If <em>the noun</em> is
still nothing after the activity finishes, then the normal parser error
will result: "You must supply a noun."</p>

<div class="codeblock">
<div class="codeline">Understand "eat" as eating. [ as opposed to "eat [something]" ]</div>
<div class="codeline">Rule <strong>for supplying a missing noun</strong> while eating: now the noun is a random edible thing in the location.</div>
</div>

<p><em>Supplying a missing second noun.</em> As above.</p>

<p><em>Deciding whether all includes.</em> When the player enter TAKE
ALL, it really shouldn't be every object. The drapes, the sun, the
kitchen sink, Bob &ndash; these should be excluded. By default, other people,
<em>scenery</em>, and <em>fixed in place</em> (i.e., nailed down)
objects are immune to ALL, but sometimes we wish to disallow other
things. The imperatives <em>it does</em> and <em>it does not</em> may be
used instead of the usual.</p>

<div class="codeblock">
<div class="codeline">Rule <strong>for deciding whether all includes</strong> something which frightens the player:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;it does not.</div>
</div>

<p><em>Deciding the scope of something.</em> Used with the phrases
<em>place (object) in scope; place (object) in scope, but not its
contents</em>; and <em>place the contents of (object) in scope.</em>
When the visibility and accessibility rules miss an object, this hook is
something of a hack. Generally, only the <em>after</em> rules are
used.</p>

<p><em>Deciding the concealed possessions of something.</em> Normally,
the parts and carried contents of people, machines, etc. are plainly
visible. But sometimes we wish the <em>particular possession</em> of the
person (or whatever) to be invisible.</p>

<div class="codeblock">
<div class="codeline"><strong>For deciding the concealed possessions</strong> of the secret assassin when the particular possession is the dagger: yes.</div>
</div>

<p><h3 id="activities-taking">Taking.</h3> This action is the most common action to
cause a change in world-state. In the text adventure days, it was
fashionable to simulate the physical world to such a degree that one had
to open doors before going through them, unlock doors before opening
them, and <em>taking</em> a nearby item before using it. As time went
on, this level of fine detail lost its novelty value, and nowadays most
players are annoyed if their character doesn't have the sense to
automatically open a door before walking through it. Automatically
taking a nearby object before eating or otherwise using it has been
bugging players long enough that the library provides for it.</p>

<p><em>Implicitly taking something.</em> If the <em>for</em> rule fails,
then TAKE won't automatically be done. This rulebook is listed in the
Index's Rules tab, at the bottom of "How Commands are Understood."</p>

<p><h3 id="activities-system-level">System level.</h3> These events bookend the game and are
rarely needed. But they occur in places that user-created code would be
hard-pressed to get into had the library not specifically exposed them,
so it's just as well that they're offered.</p>

<p><em>Constructing the status line.</em> We can already change its
contents by assigning to <em>the left hand status line</em> and <em>the
right hand status line</em>, but it's sometimes useful to use shorter
names up there due to space constraints.</p>

<div class="codeblock">
<div class="codeline">For printing the name of the fourth diagonal corridor of the sixth floor while <strong>constructing the status line</strong>:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "6th floor"</div>
</div>

<p><em>Printing the banner text.</em> This prints the title, subtitle,
author, and version information at the opening of play. Messing with
this is a quick route to making a game look amateurish. But sometimes an
<em>after</em> rule is tasteful.</p>

<p><em>Printing the player's obituary.</em> Prints the "you have died"
message followed by the score, if any.</p>

<p><em>Amusing a victorious player.</em> Prints text in response to the
command AMUSING at the game over prompt.</p>

<p><em>Starting the virtual machine.</em> Multimedia or specific VM
interpreters may need this early event, but that's about it.</p>

<p><h3 id="activities-looking">Looking.</h3> This slightly-recursive action does the
most prose generation of anything in Inform. In text adventures of old,
<em>looking</em> was your primary vehicle for delivering important
information. Nowadays <em>scenes</em> can carry much of that weight, but
the library still dedicates much of itself to ensuring which closed
containers are lit and which aren't, and what you can see from multiple
vantage points. Each level of recursion is called a <em>locale</em> and
has two parts: items with an <em>initial appearance</em>, each getting a
paragraph to itself, and the nondescript items, which are in a single
paragraph together. When we stand on a stool inside a bear pit inside
the room, <em>looking</em> will articulate what's what at each level of
recursion, starting with the outermost and working its way inward. (A
work's current rules for these activities are listed in the "How Things
are Described" section of the Rules tab of the Index.)</p>

<p><em>Looking</em> uses two properties for bookkeeping:
<em>mentioned</em> and <em>marked for listing</em>. Things are
initialized to <em>not mentioned</em> early in the process, and after
printing an item's <em>initial appearance,</em> or if the item was used
in <em>writing a paragraph about</em>, the item is then
<em>mentioned</em>. After the <em>interesting locale paragraphs
rule</em> finishes iterating, the leftover items still <em>not
mentioned</em> are initialized to <em>marked for listing</em>, so the
final <em>listing nondescript items</em> activity can list them in a
single paragraph.</p>

<p><em>Initial appearance</em>, by the way, is set by the text that
floats by itself after an item.</p>

<div class="codeblock">
<div class="codeline">The worn-out tennis shoes are a wearable thing. <strong>"Your trusty tennies lounge by the front door."</strong></div>
</div>

<p>The behavior is deep enough to require an illustrated callgraph of
sorts. Rules are marked with a rule icon üìè. Activities are marked with
a hammer and wrench icon üõ† and their names are in bold. Parenthetical
remarks provide information about the rule's purpose or activity's
  parameters.</p>

<p>
[the <em>carry out looking</em> rulebook]<br>
      <ul role="list">
<li class="rule"><span class="list-entry">room description heading rule (prints the room's <em>printed
name</em> property)</span></li>
<li class="rule"><span class="list-entry">room description body text rule (prints the room's
<em>description</em> property)</span></li>
<li class="rule"><span class="list-entry">room description paragraphs about objects rule (it doesn't really
recurse, but iterates on ever-smaller domains)</span></li>
<li class="activity"><span class="list-entry">[<strong><em>Before</em> Printing the Locale Description</strong>
of <em>the room, container, or supporter</em>] (activity)</span>
<ul role="list">
<li class="rule"><span class="list-entry">initialise locale description rule (initializes objects to <em>not
mentioned</em>)</span></li>
<li class="rule"><span class="list-entry">find notable locale objects rule</span>
<ul role="list">
<li class="activity"><span class="list-entry">[<strong>Choosing Notable Locale Objects</strong> for <em>the
room, container, or supporter</em>] (activity)</span>
<ul role="list">
<li class="rule"><span class="list-entry">standard notable locale objects rule (uses <em>set locale priority
of (object) to 5</em> on each object)</span></li>
</ul></li>
</ul></li>
</ul></li>
<li class="activity"><span class="list-entry">[<strong><em>For</em> Printing the Locale Description</strong> of
<em>the room, container, or supporter</em>] (activity)</span>
<ul role="list">
<li class="rule"><span class="list-entry">interesting locale paragraphs rule (sorts objects in <em>locale
priority</em> order)</span>
<ul role="list">
<li class="activity"><span class="list-entry">[<strong>Printing a Locale Paragraph about</strong> <em>the
prop</em>] (activity)</span>
<ul role="list">
<li class="rule"><span class="list-entry">don't mention player's supporter in room descriptions rule (marks
it <em>mentioned</em>)</span></li>
<li class="rule"><span class="list-entry">don't mention scenery in room descriptions rule (marks it
<em>mentioned</em>)</span></li>
<li class="rule"><span class="list-entry">don't mention undescribed items in room descriptions rule (marks
it <em>mentioned</em>)</span></li>
<li class="rule"><span class="list-entry">set pronouns from items in room descriptions rule</span></li>
<li class="rule"><span class="list-entry">offer items to writing a paragraph about rule</span>
<ul role="list">
<li class="activity"><span class="list-entry">[<strong>Writing a Paragraph About</strong> <em>the prop</em>]
(empty; for author use) (activity)</span></li>
</ul></li>
<li class="rule"><span class="list-entry">use initial appearance in room descriptions rule (prints the
<em>initial appearance</em> property)</span></li>
<li class="rule"><span class="list-entry">describe what's on scenery supporters in room descriptions rule
("On the scenery-supporter is ")</span></li>
</ul></li>
</ul></li>
<li class="rule"><span class="list-entry">you-can-also-see rule (initializes <em>marked for listing</em> and
calls activity)</span>
<ul role="list">
<li class="activity"><span class="list-entry">[<strong>Listing Nondescript Items</strong> for <em>the prop</em>]
(says "[In/On the supporter/container] you can [also] see ") (activity)</span>
<ul role="list">
<li class="activity"><span class="list-entry">[<strong>Printing Room Description Details</strong> of <em>the
prop</em>] (but <em>the item described</em> is the room) (activity)</span></li>
</ul></li>
</ul></li>
</ul></li>
<li class="activity"><span class="list-entry">[<strong><em>After</em> Printing the Locale Description</strong>
of <em>the room, container, or supporter</em>] (empty) (activity)</span></li>
<li class="rule"><span class="list-entry">check new arrival rule</span></li>
      </ul>
</p>

<p><em>Printing the locale description of something.</em> This is the
big, overarching activity within the <em>carry out looking</em> rule
<em>room description paragraphs about objects</em>. If we stand on a
stool, in a bear pit, in the room, this iterates through those
"locales", from outside to inside, so it feels like recursion without
actually being so.</p>

<p><em>Choosing notable locale objects for something.</em> This
initializes each item's local priority to five. In an <em>after</em>
rule, we can <em>set the locale priority of (object) to (number)</em> to
enforce a particular ordering of the objects. One is high priority. The
activity is called once per locale &ndash; the parameter is the room (or
whatever) &ndash; so a <em>for</em> rule on a room should set priorities on
all objects in it. A priority of zero is not mentioned.</p>

<p><em>Printing a locale paragraph about.</em> Finally, it's time to
start printing prose to the screen. Well, not all objects deserve any
mention whatsoever. The player is one of them &ndash; it is
<em>undescribed</em>. This activity will 1) filter out objects with the
<em>scenery</em> and/or <em>undescribed</em> properties, then 2) filter
out the supporter the player is on (since it was mentioned in the room
heading), then 3) offers the remaining items to <em>writing a paragraph
about</em>. If that activity had nothing to say, then it continues by 4)
printing the <em>initial appearance</em> property, if any, and then 5)
if the object is a scenery supporter with non-scenery stuff on it, it
will describe the supporter and its contents.</p>

<p><em>Writing a paragraph about.</em> Initially empty, this is intended
for the author's use. It overrides <em>initial appearance.</em> As is
usual, say-phrases in properties execute faster than rules which must be
considered. This activity is called several times per LOOK.</p>

<p><em>Listing nondescript items of something.</em> Items lacking
<em>initial appearance</em> or a <em>writing a paragraph about</em> rule
will be <em>marked for listing</em>, then fall into here. This activity
prints one sentence, via the <em>listing contents</em> activity. This
activity's line may begin with "On the (supporter), you" or "In the
(container), you" if the locale isn't a room.</p>

<p><em>Printing room description details of something.</em> Some items'
names are trailed by a parenthetical filled only with properties like
<em>open, closed,</em> or <em>empty</em>. This only occurs in the
you-can-also-see line of a room description. This activity allows
changing these parenthetical messages. (With the Default Messages
extension, these are library messages 101 through 107.)</p>

<p><h3 id="activity-darkness">Darkness.</h3> Like bottomless pits in platformers,
darkness has been one of the commonest tropes in text adventures,
stretching back to its earliest caving days. While in 2010 darkness can
be simulated with a single <em>instead</em> rule, the library has always
supported it, and supports it still. The following five activities each
only print a message, any of which could be replaced with extensions
like Default Messages or Custom Library Messages. While these activities
might be useful if we create a game involving heavy use of light and
dark &ndash; replacing the default message with a say phrase that calls a
rulebook would give the same effect &ndash; we can otherwise ignore their
existence. They take no parameters. The truth state variable <em>the
darkness witnessed</em> remembers if the player has ever been in the
dark.</p>

<p><em>Printing the announcement of darkness.</em> "It is now pitch dark
in here!"</p>

<p><em>Printing the name of a dark room.</em> "Darkness"</p>

<p><em>Printing the description of a dark room.</em> "It is pitch dark,
and you can't see a thing."</p>

<p><em>Printing a refusal to act in the dark.</em> "It is pitch dark,
and you can't see a thing." The visibility rulebook decides if this
activity is called.</p>

<p><em>Printing the announcement of light.</em> Performs try
looking.</p>

<p><h3 id="new-activities">New Activities.</h3> Occasionally we wish to create an
activity of our own. Extensions tend to find this useful more often than
game-specific code, but if some kind of complex interaction is
complicated enough, or is worthy of altering narration via
<em>while</em>, it may warrant an activity. An activity takes at most
one parameter, of any type. <em>Something</em> must exist if it takes a
parameter, and <em>on type</em> must exist if the parameter type is not
<em>object</em>.</p>

<p>Planning <em>something</em> <strong>is an activity</strong>
<em>on</em> people.</p>

<p>Drama management <em>something</em> <strong>is an activity</strong>
<em>on</em> scenes.</p>

<p>The name of the activity will always have <em>before, after,</em> or
<em>for</em> in front of it, so name accordingly. The <em>for</em> stage
of an activity should, by default, have a single <em>last</em> rule
which provides the default behavior. Other <em>for</em> rules will
always fall in front of the default, getting first shot at handling the
situation. Again, the words <em>of, for,</em> and <em>rule</em> may
appear or not between rulebook name and parameter description.</p>

<div class="codeblock">
<div class="codeline"><strong>Last</strong> <strong>for planning</strong> for someone (called our thinker): say "[Our thinker] can't think of anything to do." instead.</div>
</div>

<p>Finally, the phrase <em>carry out the (activity) with
(parameter)</em> invokes the activity. It must appear somewhere in our
code or our activity will never be used. The <em>the</em> is
required.</p>

<div class="codeblock">
<div class="codeline"><strong>Before drama management</strong> for the entire game, <strong>carry out the</strong> <em>planning activity</em> <strong>with the player</strong>.</div>
</div>

<h2 id="testing-commands">Testing Commands</h2>
<p>We have one testing command in the language itself:</p>

<div class="codeblock">
<div class="codeline">Test me with " look / test foobar / wave ".</div>
<div class="codeline">Test foobar with " look / take me / jump ".</div>
</div>

<p>This will execute the slash-separated list of runtime commands when
the TEST runtime command is issued. <em>Me</em> is the usual name for
the top-level test script.</p>

<p>We have several run-time testing commands at our disposal.</p>

<p>SHOWME an object: Will list the current values of all the properties
of that object, including any relations it's involved in.</p>

<p>RULES: Will list the name of a rule before it executes.</p>

<p>RULES ALL: Will list the name of a rule before it considers
  execution.</p>

<p>RULES OFF: Turns off the mode.</p>

<p>ACTIONS / ACTIONS OFF: Will list when actions begin and end.</p>

<p>RELATIONS: Lists the current state of all relations.</p>

<p>SCENES / SCENES OFF: Lists the scenes currently happening, and will
update us when one begins or end.</p>

<p>TREE: Shows all instantiations, indented according to the containment
relation. TEST a test script: Runs the list of commands.</p>

<p>PURLOIN an object: Immediately places the object in the player's
inventory, no questions asked.</p>

<p>ABSTRACT object TO object: Similar to purloin, but gives the first
object to the second object, which is likely to be a container or some
such.</p>

<p>GONEAR an object: Moves the player to the room which has the
object.</p>

<p>RANDOM: Random number generator now predictable.</p>

<p>SHOWVERB: Shows I6-level information about a verb: synonyms,
arguments, whether the arguments are reversed for a particular line.</p>

<p>SCOPE: Show all objects currently in scope.</p>

<p>SCOPE object: Show the scope from the particular object.</p>

<p>TRACE a number: Shows very low-level parsing information. The number
ranges from 1 (the default) to 6 (the most detailed).</p>

<p>The IDE has the <em>skein</em> &ndash; which is a tree of commands of
every playthrough we've done in the IDE &ndash; and the <em>transcript</em>
&ndash; which is a detail view of one path in the skein. It has the output
text from those commands. The transcript also has the <em>bless</em>
button, so automated re-testing of changes is possible.</p>

<h2 id="times-turns-and-tenses">Times, Turns, and Tenses</h2>
<p>Narratively, flags and counters are some of the most useful
pure-coding constructs in interactive fiction. Varying the prose on what
has or hasn't been done before, or at all, has been so important to the
form (and cluttering source code for so long) that Inform counts and
flags many things automatically, providing the results to us in the form
of specialized syntax. Besides 1) the global <em>time of day</em> and
<em>turn count</em> variables, Inform automatically tracks 2) how long
until a scheduled event will occur, with <em>at</em> rules, 3) how many
times an action was attempted, or a condition became true, with <em>for
the Nth time</em>, 4) for how many turns in a row a condition stayed
true or an action was attempted, with <em>for N turns,</em> 5) if an
action has ever succeeded on an object or a condition has ever become
true, via the perfect tenses, and 6) the world-state as it was on the
previous turn, via the past tenses. Once learned, these become major
tools in the construction of a quality game and very readable
source.</p>

<p>1. The variables <em>the time of day</em> and <em>the turn count</em>
hold the current value for each. We test these same as any
variable.</p>

<div class="codeblock">
<div class="codeline">Instead of going when <strong>the time of day</strong> is before 5 pm, say "It ain't quittin' time yet."</div>
<div class="codeline">After looking when <strong>the turn count</strong> is one, say "And so your adventure begins."</div>
</div>

<p>2. We can schedule an event (a rule) to fire in the future. Method one
  is hard-coding an in-game time. It fires only once.</p>

<div class="codeblock">
<div class="codeline"><strong>At 12:00 PM:</strong> say "The lunch bell rings!"</div>
</div>

<p>Method two is more flexible because it can be re-scheduled. First, we
name the event. In the following example, <em>the watch will beep</em>
is a rule, which lives in an opaque, unnamed pseudo-rulebook only while
it is scheduled. (Else, it's unlisted.)</p>

<div class="codeblock">
<div class="codeline"><strong>At the time when</strong> the watch will beep: say "Your Casio beeps at you urgently."</div>
</div>

<p>Then we schedule it imperatively. The <em>at</em> phrase takes type
<em>time</em>, while <em>in</em> takes a number of either turns or
minutes. Note that <em>turn/turns</em> is part of the phrase, while
<em>minutes</em> is part of the <em>time</em> type. A turn is an action,
and is related to time by the ratio of one turn to one minute, though
extensions such as Phrases For Adaptive Pacing can modify this.</p>

<div class="codeblock">
<div class="codeline">Carry out waiting until: the watch will beep <strong>at</strong> the time understood.</div>
<div class="codeline">Carry out waiting for: the watch will beep <strong>in</strong> the time understood <strong>from now</strong>.</div>
<div class="codeline">Carry out pushing the watch: the watch will beep <strong>in</strong> six minutes <strong>from now<em>.</strong></em></div>
<div class="codeline">Carry out pushing the watch: the watch will beep <strong>in</strong> six <strong>turns from now</strong>.</div>
</div>

<p>An event can safely re-schedule itself.</p>

<p>When play begins, the alarm clock goes off <strong>at</strong> 6:30
am.</p>

<div class="codeblock">
<div class="codeline"><strong>At the time when</strong> the alarm clock goes off:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "Your alarm clock wakes you up.";</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;the alarm clock goes off <strong>at</strong> 6:30 am.</div>
</div>

<p>3. Inform counts how many times an action was attempted which our rule
  preambles query like the following.</p>

<div class="codeblock">
<div class="codeline">Before taking the candle <strong>once</strong>: say "Hey, it's a candle.".</div>
<div class="codeline">Before taking the candle <strong>twice</strong>: say "You guess you'll need that candle again after all.".</div>
<div class="codeline">Before taking the candle <strong>for the third time</strong>: say "Your life seems tied to this candle.".</div>
<div class="codeline">Before taking the candle <strong>for at least 4 times</strong>: say "Sigh.".</div>
</div>

<p>These action amendments count both successful and unsuccessful
attempts, so we should confine them to rules guaranteed for
consideration every turn: <em>before</em> and <em>every turn</em>, and
early in <em>persuasion</em> and <em>instead</em>. Any later than that
and we must take precaution that the rule isn't pre-empted, missing the
chance to even see the Nth attempt.</p>

<div class="codeblock">
<div class="codeline">Check burning when the candle is unlit <strong>once</strong>: say "You'll need to light the candle first." instead.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Check burning when the candle is unlit <strong>twice</strong>: say "Again, your source of fire needs be lit first." instead.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Check burning when the candle is unlit <strong>for at least the third time</strong>: say "The candle is out again." instead.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">After burning the candle <strong>twice</strong>:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;say "If a <em>check</em> rule blocks the second attempt, this <em>after</em> rule never fires. But even if this rule does fire, it isn't necessarily narrating the second time the candle was successfully lit up. The first attempt may have failed, so this rule would be firing on the first successful attempt."</div>
</div>

<p>The <em>for the Nth time</em> amendment can also be added to
relations and conditions to check how many times they become true.</p>

<div class="codeblock">
<div class="codeline">Every turn when the candle is lit <strong>for at least the third time</strong>: say "The oft-used candlewick lights easily.".</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Every turn when the player carries all the gear <strong>for the third time</strong>, say "How did I get stuck being the pack mule?".</div>
</div>

<p>4. Inform also counts for how many <em>turns [in a row]</em> something
has remained true. The syntax uses the word <em>turns</em> rather that
<em>times</em> for this, as it's a measure of duration rather than a
discrete tally of occurrences. If used on actions, it means that the
action was done multiple times <em>in a row</em>. Indeed, to keep the
distinction clear, it's helpful to mentally amend the words <em>in a
  row</em> to any <em>for X turns</em> amendment.</p>

<div class="codeblock">
<div class="codeline">Every turn when the player does not carry the sprite <strong>for at least 3 turns</strong>:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "The sprite sings a lonely song.".</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Every turn when the candle is lit <strong>for five turns</strong>, say "Your candle burns on.".</div>
<div class="codeline">Every turn when the player carries all the gear <strong>for ten turns</strong>, say "Isn't it someone else's turn to carry this stuff?".</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Check jumping <strong>for three turns</strong>: say "You ain't gettin' any higher." instead.</div>
</div>

<p>It's rare to see a <em>turns</em> amendment directly on an action as
we've done with <em>jumping</em>, because it's rare for a player to type
in the same command three times in a row and expect different results.
<em>For X turns</em> make more sense with relations, properties, and
conditions because they have a tendency to hold their value over very
long periods of time. By contrast, <em>for X times</em> makes sense on
nearly anything, though when used on actions needs to occur early in
processing so <em>check</em> rules and whatnot don't rob it of its only
chance to fire.</p>

<p>The narrative use of these amendments is for varying the narration of
repetition. Interactive fiction differs from video games in that a first
success is worth reading about, and the second only to ensure that
you've learned the skill, but after that why tell the reader again. It's
old news. Of course, repetitive failure is not much fun either, but that
at least has a narrative role as struggle. And perhaps a gameplay role
too, as puzzle-solving.</p>

<p>5. A few of these inflections Inform gives a meaning to. The perfect
tenses mean "have ever been true". So an action in the present-perfect,
<em>if we have taken the candle</em>, begins the game false, becomes
true on the first successful TAKE, and never again changes value.
Relations, like <em>if Bob has carried the candle</em> work similarly,
but the implementation differs. Each object has a hidden bit array
property holding the answers to <em>if we have</em> queries, so
questions of the form <em>if we have taken the noun</em> work fine.
Relations are case-by-case: an implicitly-created variable
BobHasCarriedCandle holds this answer. So actions accept variables like
<em>the noun</em> but no subject &ndash; the <em>we are</em> is literal,
required, and has no synonyms &ndash; while relations accept a subject like
<em>Bob</em> but no variables &ndash; BobHasCarriedNoun just won't work
right.</p>

<div class="codeblock">
<div class="codeline">if Grognar <strong>has carried</strong> the Sword of Smiting, [...]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">if Bob <strong>has ever remembered</strong> the time he spent in jail, [ present is <em>can remember</em> -- <em>can</em> becomes <em>ever</em> ]</div>
</div>

<p>The perfect tenses, like stories in general, are about irrevocable
developments. While the condition <em>if Grognar carries the Sword of
Smiting</em> is correct when we're checking to see if he can swing the
sword, it isn't correct if an character asks him to describe the sword.
Sure, if he has never encountered the mythical blade he has no
first-hand knowledge of it, and if he does carry it then he certainly
can describe it. But if the sword is temporarily separated from him,
asking him under the simple present tense produces a false negative.
Grognar has learned what the blade looks like, and that is as
irrevocable as discovering the villain is his own father. This then is
where the perfect tenses come in: knowledge and plot points.</p>

<p>Before moving on, a quick detail about testing the present for the
sake of syntax consistency: when testing whether or not a particular
action is currently going on that turn, <em>we are</em> is accepted in
front of the action, but is optional. This mirrors the <em>we have</em>
of the present-perfect.</p>

<div class="codeblock">
<div class="codeline">[ perfectly synonymous ]</div>
<div class="codeline">Every turn: if <strong>taking</strong> something unique, [...]</div>
<div class="codeline">Every turn: if <strong>we are taking</strong> something unique, [...]</div>
</div>

<p>6. Relations also support the past and past-perfect tenses. If you've
ever implemented a linked list, you likely know how useful a "previous"
node pointer is in addition to the "current" node pointer, especially
for updating those very node linkages. Similarly, when the condition of
an if-statement is asked in simple past tense, it queries the previous
turn's game state, not the current one. For example, when phrased in
present tense the following lines of code would be broken: the candle
would always be lit afterward regardless its state beforehand. But
written in past tense, the lines indeed toggle the <em>lit</em>
  property.</p>

<div class="codeblock">
<div class="codeline">if the candle <strong>was</strong> lit, now the candle is unlit;</div>
<div class="codeline">if the candle <strong>was</strong> unlit, now the candle is lit;</div>
</div>

<p>(Properties use the verb relation <em>is/was</em>. Again, properties
are a special case of relations.) Remember that by itself the simple
past tense only asks a question of the immediately previous state, not
necessarily what changed since the previous turn. So the following
wouldn't do what was intended.</p>

<div class="codeblock">
<div class="codeline">if Bob <strong>managed</strong> the player, say "So long, Mr. Picky!"</div>
</div>

<p>When Bob was the manager on the previous turn, most likely it is
because he is the manager now, too. Try this instead.</p>

<div class="codeblock">
<div class="codeline">if Bob <strong>managed</strong> the player <strong>and</strong> Bob <strong>does not manage</strong> the player, say "So long, Mr. Picky!"</div>
</div>

<p>We recognize change by bracketing it with two world-states, the
present one and the previous turn's (past) one. And should the player
again come under the tyranny of Bob, the message will be re-printed when
he yet again leaves Bob. Now we can greet our new manager.</p>

<div class="codeblock">
<div class="codeline">if Joan <strong>did not manage</strong> the player and Joan <strong>manages</strong> the player, say "Hello, Joan."</div>
</div>

<p>The past-perfect (<em>if X had been Y</em> or <em>if Bob had managed
Dave</em>) relates to the present-perfect as the simple past relates to
the simple present: the past-perfect remembers the previous turn's
present-perfect value. Because the present becomes the past at the end
of a turn, during the <em>update chronological records rule</em> found
in the <em>turn sequence</em> rulebook, and because the perfect tenses
do not change once set, the only time throughout the entire game when
the past-perfect isn't equal to its present-perfect twin is during the
end of the one turn that changes the present-perfect.</p>

<p>To continue Joan's example, replacing the past and present with the
past-perfect and present perfect still recognizes the change via
bracketing, except this time the rule will fire at most once throughout
the entire game.</p>

<div class="codeblock">
<div class="codeline">Every turn, if Joan <strong>had not managed</strong> the player and Joan <strong>has managed</strong> the player, say "Pleased to meet you."</div>
</div>

<p>The condition must appear in <em>every turn</em> or as a scene
begin/end point because that is the only time during a turn that
past-perfect differs from its present-perfect twin.</p>

<p><strong>Edge cases.</strong> For syntactical sugar, these simple
things sure have a lot of edge cases. It isn't so much a case of bad
programming as realizing just how much common sense and filtering happen
when people speak naturally.</p>

<p><strong>Negating the Perfect Tenses.</strong> We cannot do the
following.</p>

<div class="codeblock">
<div class="codeline">Every turn, if Bob <strong>had managed</strong> the player and Bob <strong>has not managed</strong> the player, say "So long forever!"</div>
</div>

<p>It's nearly identical to the above example with Joan, except the
<em>not</em> moved. Now that rule never fires. For that rule to fire,
the perfect tense would need to transition from false to true, which
perfect tenses don't do, by definition. <em>Had</em> is always what
<em>has</em> used to be. So in the first condition <em>had</em> is
saying that <em>has</em> used to be true, while the second condition
says that <em>has</em> is false right now. It's a contradiction.</p>

<p>Even when used alone, negating the perfect tenses can be
counterintuitive. Constructions like <em>if we have not trusted</em> do
not mean "if there was a time when we did not trust", but rather, "if we
have yet to trust". It is true at the start of the game and becomes
permanently false the first time we trust, as opposed to being false at
the start of the game and becoming true the first time
<em>distrusting</em> happens. (For that effect, a <em>distrusting</em>
action really is needed, and likely a relation the twin actions set and
unset so it is possible to tell which action happened the most
recently.)</p>

<p>If this isn't clear, I can only recommend circuit timing diagrams.
Suffice to say, the perfect tenses are good for knowledge and plot
points, the past tenses are good for recognizing world-state changes by
bracketing, and when put together we can recognize additions to
knowledge.</p>

<p><strong>Combining tenses with occurrences.</strong> By these rules,
it seems rules like <em>if we have taken the candle twice</em> would
never fire, because <em>we have taken</em>, once becoming true, stays
true for the rest of the game. Since it doesn't become false again, it
cannot become true again, so <em>twice</em> is never satisfied.
Fortunately this is special-cased to work as it looks like it
should.</p>

<div class="codeblock">
<div class="codeline">Every turn when <strong>we have eaten</strong> the slow-acting poison <strong>for 5 turns</strong>: say "You start to feel ill."</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Every turn when <strong>we have eaten</strong> the slow-acting poison <strong>for at least 6 turns</strong>: say "You still feel ill."</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Check listening to the ominous skritching sound when <strong>we have taken the candle at least three times</strong>:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;say "Perhaps your life really is tied to this dim, flickering candle." instead</div>
</div>

<p><strong>Initial State.</strong> The <em>update chronological
records</em> rule is ran just before the <em>when play begins</em> rules
to set up the initial state. Prior to this very early rule, everything
is still zero, or possibly garbage, and the player is in the dark room,
"thedark", so testing the past via any of this chapter's features may
not be a good idea. It is possible to explicitly <em>follow</em> the
rule again, or to list it after the <em>position player in the model
world</em> rule to correct snafus, but this has other effects. For
example, throwing off the count in things like <em>for two turns</em>
when connected to the beginning of play.</p>

<p><strong>Timeless Actions.</strong> <em>Out of world</em> actions do
not affect time, but Inform still counts their occurrences. So we could
do this.</p>

<div class="codeblock">
<div class="codeline">Check saving the game <strong>once</strong>: say "You have two more chances to save the game."</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Check saving the game <strong>twice</strong>: say "You have one more chance to save the game."</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Check saving the game <strong>for at least four times</strong>: say "Sorry, you've already used up all your saves." instead.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Check quitting the game when <strong>we have not requested the score</strong>: say "Not curious about your score?" instead.</div>
</div>

<p>But we couldn't do this.</p>

<div class="codeblock">
<div class="codeline">Check saving the game <strong>for at least two turns</strong>: say "Saving the game multiple times in a row is a bad idea, because you only have a limited number of saves." instead.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Check quitting the game <strong>for two turns</strong>: say "All right, all right, you don't want to play anymore. Fine."</div>
</div>

<p>This is because if we clue the player that doing something thrice in
a row will have negative consequences, not only will they be certain to
try it, but they'll type SAVE just before the third and final
attempt.</p>

<p><strong>Verbs Can Pull Double-duty.</strong> It's possible to define
the same verb as both action and relation. The closest to ambiguity that
can be reached is the ungrammatical <em>if Bob watching Junior</em>,
which means the same as <em>if Bob is watching Junior</em>, which is
clearly a relation.</p>

<p>Without the relation, the former will not even compile. NPC actions
in <em>if</em> statements require <em>trying</em>: <em>if Bob trying
watching Junior</em>. Likewise changing the subject to <em>the
player</em>, which will always be a relation test, or <em>we
are/have</em>, which will always be an action test. Since the purpose of
almost all actions is to set or unset a relation, using the same verb
for both the relation and the action which sets it reduces our cognitive
load.</p>

<p>Sometimes the word <em>trying</em> needs to be inserted even when
there is no possibility of ambiguity, such as in a table column of
stored actions.</p>

<p><strong>Past Participial Adjectives versus the Passive
Voice.</strong> In English, the passive voice swaps the subject and
direct object of the sentence. The preposition <em>by</em> usually
precedes the former subject, assuming it isn't dropped entirely.</p>

<p>Clarissa drew the portrait.</p>

<p>The portrait was drawn by Clarissa. The portrait was drawn.</p>

<p>The verb phrase changes to the <em>be -en</em> form: <em>is drawn,
was drawn, am drawn, are taken, were driven,</em> etc. But most English
verbs don't have an -en (past participial) form, so they use the</p>

<p>-ed (past) form in its place: <em>is painted, was closed, am
carried.</em> It is also true that the past participle -en form can be
used as a plain adjective: <em>the drawn portrait, the taken picture,
the closed book.</em> These rules collude to produce a grammatical
ambiguity in English.</p>

<p>The door was closed.</p>

<p>That sentence might be in passive voice with a dropped subject, as in
<em>the door was closed by someone</em>, or might be an ordinary
assertion in simple past tense, as in <em>the door was not
ajar.</em></p>

<p>Inform supports the passive voice only in one instance: relation
verbs declared as <em>to be able to</em>, such as our <em>can
remember</em> example. Passive voice can be stated in the simple present
or past tenses: <em>the time he spent in jail can be remembered by
Bob</em> and <em>&hellip;could be remembered by</em>. Inform's relations do
not support passive voice in the perfect tense, nor passive voice
actions, nor any other passive voice combination. Crucially, this one
instance of passive voice that Inform does implement still requires both
parameters. We cannot say "if the time he spent in jail can be
remembered". We need the <em>by someone</em>.</p>

<p>However, Inform does support adjectives, and adjectives can be named
for a past participle. <em>Carried</em> is one such example. Though the
standard rule define <em>carry</em> as a relation, it also defines
<em>carried</em> as an adjective via <em>Definition</em>. So both of the
following are valid lines of Inform code, but for entirely different
reasons with entirely different meanings.</p>

<div class="codeblock">
<div class="codeline">if the candle is carried, [ An adjective test, not a relation test in passive voice. <em>The player</em> is implied. ]</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">if Clarissa carried a candle, [ A relation test (tipoff: two parameters) in simple past tense. ]</div>
</div>

<p>An object is <em>carried</em> only if the player carries the object.
"A person <em>carried</em> an object" only if that person was carrying
the object on the previous game turn.</p>

<p>Chapter 9.13 of the manual, Writing With Inform, gives this shining
example for the simple past tense.</p>

<div class="codeblock">
<div class="codeline">if the lantern was switched on, now the lantern is switched off;</div>
<div class="codeline">if the lantern was switched off, now the lantern is switched on;</div>
</div>

<p>Like <em>carried</em>'s dual definitions, <em>switched on</em> has
dual definitions: a <em>device</em> object has an adjective property
<em>switched on/switched off</em>, and the present-perfect tense of the
<em>switching on</em> and <em>switching off</em> actions is <em>we have
switched on</em> and <em>we have switched off</em>. But even if we also
created a <em>to be able to switch on</em> relation in addition to the
property and the action, there will still be no ambiguity in Inform.
<em>We have</em> always identifies present-perfect actions, two
parameters surrounding a verb identifies relations (even for passive)
except for when <em>trying</em> separates subject and verb (which is an
NPC present action), and one parameter identifies the adjective. A word
ending in <em>-ed</em> does not guarantee past tense &ndash; it could be the
present-perfect. And verb constructions of the form <em>be -en</em>
don't always identify passive voice &ndash; it could be a past participial
adjective in simple past.</p>

<h2 id="swapping-headings">Swapping Headings</h2>
<p>As part and parcel of literate programming, Inform provides headings
for source code. One of</p>

<p><em>volume, book, part, chapter,</em> or <em>section</em> against the
left margin denote the line as a heading.</p>

<div class="codeblock">
<div class="codeline"><strong>Volume 1 -</strong> Technical Tidbits</div>
<div class="codeline">&thinsp;</div>
<div class="codeline"><strong>Book 1 -</strong> Definitely Necessary Definitions</div>
</div>

<p>The IDE puts the heading in bold type, and the heading appears in the
contents tab above the source's pane. (Not to be confused with the
contents tab in the index.) The contents shows our source as an outline,
and can even narrow the view to just a particular portion of the whole
code. When used this way, headings are merely a way of organizing our
code, and the index.</p>

<p>Yes, the index, the usefulness of which is easy to overlook. For
those of us uncomfortable with <em>rules</em>, it shows in what order
the rules are sorted. For those of us uncomfortable with abbreviating
object names or putting spaces in identifiers, it shows all types of all
constructs. And it shows what constructs we created by typo. Even though
variables are grouped with other variables and phrases with other
phrases, each construct, in the index, is grouped under the most
specific heading it follows.</p>

<p>For the extension writer, the index is highly important because the
users of your extension may read the documentation only once, and
thereafter read the pithier index to refresh themselves on the
extension's abilities. Careful choice and naming of headings, and
careful arranging of source, create index listings that serve as flash
cards. Combined with sensible synonyms on phrases and functions, an
extension's functionality becomes easy to remember, easy to guess at,
and quick to look up.</p>

<p>Inform provides a few features that work on headings and their
contents. One is <em>unindexed.</em> Simply put, most constructs within
an <em>unindexed</em> heading don't appear in the index. Rules will
always appear, for instance, but scratchpad variables and utility
functions can be hidden. While Inform has no namespaces to speak of,
merely not advertising the existence of such works well enough, and the
extension's complete source is easily seen anyway. Again, Inform is a
white-box language.</p>

<div class="codeblock">
<div class="codeline">Section 8 - odds & ends - <strong>unindexed</strong></div>
</div>

<p>Second is <em>not for release</em>. Testing and debugging commands
are a fact of life, but should a player discover one it could harm the
game or story. So this heading amendment removes everything in its
section: rules, objects, everything. Unlike <em>unindexed</em>,
subheadings also fall under a parent heading's <em>not for
release</em>.</p>

<div class="codeblock">
<div class="codeline">Chapter 6 - testing commands - <strong>not for release</strong></div>
<div class="codeline">&thinsp;</div>
<div class="codeline">[ any <em>section</em>s within this chapter also remain unreleased ]</div>
</div>

<p>Headings can also remove, add, or replace source text with the source
text of other headings via the parenthetical amendments <em>for use
with, for use without,</em> and <em>in place of</em>. This is typically
done to modify the extensions of others without editing the files,
greatly simplifying administrative tasks such as versioning or "keeping
around an extra copy". These, too, affect their subheadings. There is a
slight restriction on <em>in place of</em>: when replacing a heading,
the replacement must be the same type of heading (<em>chapter,
section,</em> whichever).</p>

<div class="codeblock">
<div class="codeline">Chapter 2a - automatic safe cracking <strong>(for use with</strong> Locksmith <strong>by</strong> Emily Short)</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Chapter 2b - mostly automatic safe cracking <strong>(for use without</strong> Locksmith <strong>by</strong> Emily Short)</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Section 6 - hacked locking <strong>(in place of</strong> Section 1 - Regular locking <strong>in</strong> Locksmith <strong>by</strong> Emily Short) [ this is a <em>section</em> because it is a <em>section</em> being replaced ]</div>
</div>

<p>A good extension writer will break up an extension into named
sections to facilitate heading replacements. (This is of course somewhat
at odds with beautifying the index.) One extension is automatically
included in all projects: the Standard Rules by Graham Nelson. It
contains the most basic information on the class hierarchy, the built-in
actions, variables, etc., of Inform 7. For example, the properties on
class Thing are here.</p>

<div class="codeblock">
<div class="codeline">Section SR1/3 - Things</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">A thing can be lit or unlit. A thing is usually unlit.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">A thing can be edible or inedible. A thing is usually inedible.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">A thing can be fixed in place or portable. A thing is usually portable. A thing can be scenery.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">A thing can be wearable.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">A thing can be pushable between rooms.</div>
</div>

<p>And so on. Though it will likely cause compiler errors in many
places, the standard rules can be modified like any other.</p>

<div class="codeblock">
<div class="codeline">Section 8 - my thing class (<strong>in place of</strong> Section SR1/3 - Things <strong>in</strong> the Standard Rules <strong>by</strong> Graham Nelson)</div>
</div>

<p>Avoiding compiler errors by changing so much of the most basic
assumptions of the code library is difficult, but we're hardly new to
compiler errors.</p>

<h2 id="facing-inform-6">Facing Inform 6</h2>
<p>All of an Inform 7 project compiles to Inform 6 source code before
compiling again to assembly. This means all of Inform 7's constructs are
implemented in Inform 6 somehow. For example, a rule is a boolean
function that takes no passed-in parameters &ndash; action variables like
"the noun" and "the second noun" are global, while local variables are
on the stack &ndash; so a rulebook is an array of function pointers. Larger
structures such as actions and activities are composed of several
rulebooks. Object instantiations are connected together by linked-list
pointers, so a set-description may loop through them. Each
set-description compiles to a unique function containing a loop header,
and like generator functions in functional programming, they return the
first applicable value that passes muster. (The calling code, which has
the loop body, is responsible for informing the set-description where it
left off so it can find the next applicable value.) Meanwhile, scenes,
which can have properties just like objects, are implemented as several
different arrays, one per property. So a scene name is just a named
value, an index into those arrays. And because a single table column's
entries all have the same type, a table column is an array plus a few
header bytes, while a table is an array pointing to those columns. And
so on and so forth.</p>

<p>The implementation for all these constructs is found in the template
files within the Inform application. These text files, which have the
extension <em>i6t</em>, we can modify from our Inform 7 source similar
to section headings. We can replace parts of them, or insert additional
bits between them.</p>

<div class="codeblock">
<div class="codeline">Include <code>(- ... blah blah blah... -)</code> before "Relations.i6t".</div>
<div class="codeline">Include <code>(- ... blah blah blah... -)</code> instead of "Relations.i6t".</div>
<div class="codeline">Include <code>(- ... blah blah blah... -)</code> after "Symmetric One To One Relations" in "Relations.i6t".</div>
</div>

<p>Usually we just need to pull out a bit of useful information or add
in a useful line in the generated source. The commonest way is by
creating a to-phrase or to-decide function whose entire body is Inform 6
code between the <code>(-</code> and <code>-)</code></code> markers. This
inserts the exact text into the compiled Inform 6. So, generally,
to-phrases must end in a semicolon, while to-decide functions, which are
frequently if-conditions or r-values, must not.</p>

<div class="codeblock">
<div class="codeline">To decide what number is the chosen table row: <code>(- ct_1 -)</code>.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">To decide what number is the first misunderstood parser word: <code>(- (wn - 1) -)</code></div>
<div class="codeline">&thinsp;</div>
<div class="codeline">To decide which number is (x - a number) ORed with (y - a number): <code>(- ({x} | {y}) -)</code>.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">To really clear the screen: <code>(- VM_ClearScreen(0); statuswin_cursize = 0; -)</code></div>
</div>

<p>Parameters go between curly braces. There's two parameter types
useable here unavailable to pure Inform 7. <em>Condition</em> is
something appropriate to follow an <em>if</em>. <em>Action</em> compiles
to an invocation of <em>TryAction()</em>. Inline assembly may be
included amongst the Inform 6 like any other statement. Assembly opcodes
always begin with a @ sign.</p>

<div class="codeblock">
<div class="codeline">To do this: <code>(- do { -)</code>. [ not ending with a semicolon here, obviously ]</div>
<div class="codeline">To until (C - a condition): <code>(- } until {C}; -)</code>.</div>
<div class="codeline">To push (x - a word value) onto the stack: <code>(- @push {x}; -)</code>.</div>
<div class="codeline">To pull (x - a word value) from the stack: <code>(- @pull {x}; -)</code>.</div>
</div>

<p>Other Inform7 variables may be accessed by placing the name between
(+ and +) markers. Rules may be invoked by following the markers with
empty parenthesis, since rules never take a parameter. Named to-phrases
expand, not to the function, but to an array of metadata about the
function. Index 1 holds the function pointer, so the syntax would
resemble
<code>((+ my I7 phrase +)--&gt;1)( ... any parameters ... )</code> while
indexes 0 and 2 hold the type and printable name, respectively.</p>

<p>An extended example: the author wants to save actions for later
display or execution from a hint system or CYOA menu. One goal is as
always a nice Inform 7 syntax, preferably without using <em>the action
of</em> keywords that herald a stored action. So he reaches for the
<em>action</em> parameter type, which requires an Inform 6 inclusion,
then reflects the Inform 6 right back into an Inform 7 to-phrase, which
has all five parameters of the <em>TryAction()</em> invocation, plus two
new parameters: a description of people, and whichever rule is currently
held in his <em>extra behavior</em> variable.</p>

<p>The first line here shows the resulting syntax within a Before
rule.</p>

<div class="codeblock">
<div class="codeline">Before an actor opening something locked, a strong person in the location could try attacking the noun.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">The extra behavior is a rule that varies.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">To (P - a description of people) could try (invocation - action):</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;<code>(- Could{invocation}{-backspace}{-backspace}, {P}, (+ extra behavior +) ); -)</code>.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Include <code>(-</div>
<div class="codeline">[ CouldTryAction req actr act n sn desc exbehvr;</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;((+ remembering for later +)-->1)(req, actr, act, n, sn, desc, exbehvr);</div>
<div class="codeline">];</div>
<div class="codeline">-)</code>.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">To (requested - truth state) intention by (dont-use-this - a person) considering (possible-action - an action name) via (possible-noun - an object) & (possible-second- noun - an object) by any able-bodied (faction - a description of people) with (behavior - a rule) (this is remembering for later): [ .. and so on ... ]</div>
</div>

<p>After Inform 7 expands the parameter <em>{invocation}</em> to
<em>TryAction(v,w,x,y,z);</em> the pair of <em>{- backspace}</em> macros
erase the semicolon and closing parenthesis so additional parameters
could be added. Furthermore, we simply prepend the word "Could" in front
of the function name to form a different function name altogether,
<em>CouldTryAction()</em>, which we instructed to call the complicated
to-phrase.</p>

<p>The last use of the <code>(- and -)</code> markers is to create a compile-time
assertion, which Inform 7 calls "use options". To use the following we'd
just assert it like any other use option: <em>Use the American dialect,
RULES ALL at start, and no scoring.</em></p>

<div class="codeblock">
<div class="codeline">Use RULES ALL at start translates as <code>(- Global debug_rules=2; -)</code>.</div>
</div>

<p>The line will be included if the source includes the use option,
otherwise not.</p>

<p>The other way of tinkering with Inform 6 is to expose a pre-existing
variable, function, etc. by naming it with an Inform 7 name. Unlike the
methods above, this allows us to assign to variables directly.</p>

<div class="codeblock">
<div class="codeline">Out-of-world is a truth state that varies.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">The out-of-world variable translates to I6 as "meta".</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">The currently-executing action is an action name that varies.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">The currently-executing action variable translates into I6 as "action".</div>
</div>

<p>Properties, rules, understand tokens, <em>Definition:</em>
adjectives, instantiations, and classes may be translated similarly.
Translating is necessary because the generated I6 names differ from
their I7 counterparts to prevent any unfortunate name clashes. But
because I6 implements much of I7, tinkering requires communication
between the layers. One example is new tokens for use in understand
assertions, which inform the parser, written solely in Inform 6.</p>

<div class="codeblock">
<div class="codeline">The understand token subordinating conjunction translates into I6 as "SUB_CONJ_TOKEN".</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Include <code>(-</div>
<div class="codeline">[ SUB_CONJ_TOKEN;</div>
<div class="codeline">return ((+ parsing the sub conj +)-->1)();</div>
<div class="codeline">];</div>
<div class="codeline">-)</code>.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">To decide which number is parse succeeds: <code>(- GPR_PREPOSITION -)</code>.</div>
<div class="codeline">To decide which number is parse fails: <code>(- GPR_FAIL -)</code>.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">To decide which number is parse the sub conj (this is parsing the sub conj):</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;repeat through the table of subordinating conjunctions:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if the unmatched word matches the topic entry:</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;now the sub conj is the output entry;</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decide on parse succeeds;</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;decide on parse fails.</div>
</div>

<p>We can declare global I6 variables from Inform 7, and not expose them
to Inform 7 if we wish.</p>

<div class="codeblock">
<div class="codeline">Include <code>(-</div>
<div class="codeline">Global save_debug_rules;</div>
<div class="codeline">-)</code>.</div>
</div>

<p>When Inform 7 is creating Inform 6 code, it recognizes a few macros
beside just <em>{- backspace}</em>. Although innocuous enough, these
facilities open up whole new categories of things phrases can do.
Counters are the first. Each time a phrase uses <em>{-advance-
counter:FOOBAR}</em>, the current value of the number variable FOOBAR
replaces it as a constant literal, and FOOBAR is then post-incremented.
The variable is inside the Inform 7 compiler, not in our source code
(either I7 or I6). One example of its use is debugging. Let's say we
have a complicated I6 inclusion that crashes with a runtime error, but
only sometimes. We use the phrase in three different places in our code,
and know not which is causing the problem. We could define it like
so.</p>

<div class="codeblock">
<div class="codeline">To do complicated thing:</div>
<div class="codeline"><code>(-</div>
<div class="codeline">print "invocation #", {-advance-counter:BigThing}, "^";</div>
<div class="codeline">! blah blah blah</div>
<div class="codeline">-)</code>.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">When play begins, do complicated thing.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">Every turn, do complicated thing.</div>
</div>

<p>Each place that "do complicated thing" appears in the source has its
own number, starting from zero. We can also put the macro next to a
variable name, like <em>myvar{-advance- counter:MyVarCount}</em>, so the
resulting Inform 6 code references variables <em>myvar0</em>,
<em>myvar1</em>, etc.</p>

<p>Related are <em>{-zero-counter:FOOBAR}</em> which sets the counter
back to zero, and <em>{- counter:FOOBAR}</em> which becomes the number
without increasing the number afterward. Just to be clear,
<em>{-advance-counter:FOOBAR}</em> post-increments, and in case that
causes a problem, it can be placed in an Inform 6 comment, where its
expansion is ignored.</p>

<p>Finally in this series on counters is
<em>{-allocate-storage:FOOBAR}</em>. The above counters only existed in
our resulting Inform 6 source as constants, but this instruction creates
actual storage space in our Inform 6 source, an array called
<em>I7_ST_FOOBAR</em>, which has at least the number of elements as the
FOOBAR counter. The counter is how each I7 phrase invocation knows which
array element belongs to it, so
<em>I7_ST_FOOBAR--&gt;{-advance-counter:FOOBAR}</em> appears in our
definition precisely once. Should we need to reference storage multiple
times in the same definition, it appears last (because it
post-increments) and one or more
<em>I7_ST_FOOBAR--&gt;{-counter:FOOBAR}</em> appear. For example, if our
phrase defines a new kind of loop, and we want the loops to be able to
nest, this construction solves our problem.</p>

<div class="codeblock">
<div class="codeline">To repeat with (R - nonexisting rule variable) running through future events begin -- end:</div>
<div class="codeline"><code>(-</div>
<div class="codeline">{-allocate-storage:LoopingThruEvents} ! expands to nothing, and no further effect for multiple appearances</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">for ( I7_ST_LoopingThruEvents-->{-counter:LoopingThruEvents} = 1</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;: I7_ST_LoopingThruEvents-->{-counter:LoopingThruEvents} <= TimedEventsTable-->0</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;: (I7_ST_LoopingThruEvents-->{-counter:LoopingThruEvents})++ )</div>
<div class="codeline">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (({R} = TimedEventsTable-->(I7_ST_LoopingThruEvents-->{-advance- counter:LoopingThruEvents})) ~= 0)</div>
<div class="codeline">-)</code>.</div>
<div class="codeline">&thinsp;</div>
<div class="codeline">[ that's an assignment inside the condition ]</div>
</div>

<p>And finally, almost as an afterthought: occasionally we write phrases
for tables. Tables require some local variables, such as ct_1. The macro
{-require-ctvs} tells Inform to create said variables.</p>

<p>This is only most of Inform 7. It is a large language with many nooks
and crannies to explore.</p>

<p>Finding them is frequently a game in itself. I hope you find it as
enjoyable as I have.</p>

<h2 id="ready">READY.</h2>

<div class="codeblock">
<div class="codeline"><code>&gt;_</code></div>
</div>
    </main>
<footer>
  <div class="footing">
    <p>The original <a href="http://www.plover.net/~pscion/Inform%207%20for%20Programmers.pdf">Inform 7 Programmer's Manual (PDF)</a> was written by Ron Newcomb; this reformatted for the web version is shared with his permission.</p>
    <p>It was last revised in 2011 for Inform 7 8.5/6G60; the subsequent 9.1/6L02 brought several backwards-incompatible language changes, so there are several details herein that are out of date relative to 9.1 and subsequent versions. Every effort has been made to be faithful to the original, changing the text only where it referred to specific formatting, to correct a typo, or, where it aided readability, to change the placement of a code comment or add a <code>[...]</code> code comment.</p>
    <p>Due to Inform 7's syntactically-significant tabs, if you cut-and-paste the example code, in general you shouldn't expect it to work without modification.</p>
    <p class="about"><a class="raw" href="../index.html">Inform 7 documentation</a> (unofficial web remix)</p>
    <p class="about"><a class="raw" href="https://mastodon.gamedev.place/web/@inform7tips">@inform7tips@mastodon.gamedev.place</a></p></div></footer>
  </body>
</html>
